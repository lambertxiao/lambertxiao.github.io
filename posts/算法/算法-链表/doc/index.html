<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>算法-链表 | Lambert&#39;s blog</title>
<meta name="keywords" content="算法" />
<meta name="description" content="2. 两数相加 2. 两数相加
给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
206. 反转链表 206. 反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
func reverseList(head *ListNode) *ListNode { // 双指针，pre和curr一前一后  var pre *ListNode curr := head for curr != nil { tmp := curr.Next curr.Next = pre pre = curr curr = tmp } return pre } func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } nhead := reverseList(head.">
<meta name="author" content="Lambert Xiao">
<link rel="canonical" href="https://lambertxiao.github.io/posts/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/doc/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.f930089bcedc85892fe03ed179c7aff545249b87bdabbcac09cc1895e74257eb.css" integrity="sha256-&#43;TAIm87chYkv4D7Recev9UUkm4e9q7ysCcwYledCV&#43;s=" rel="preload stylesheet" as="style">
<link rel="preload" href="/avatar.jpeg" as="image">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://lambertxiao.github.io/avatar.jpeg">
<link rel="icon" type="image/png" sizes="16x16" href="https://lambertxiao.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lambertxiao.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lambertxiao.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lambertxiao.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="算法-链表" />
<meta property="og:description" content="2. 两数相加 2. 两数相加
给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
206. 反转链表 206. 反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
func reverseList(head *ListNode) *ListNode { // 双指针，pre和curr一前一后  var pre *ListNode curr := head for curr != nil { tmp := curr.Next curr.Next = pre pre = curr curr = tmp } return pre } func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } nhead := reverseList(head." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lambertxiao.github.io/posts/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/doc/" /><meta property="og:image" content="https://lambertxiao.github.io/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-13T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2022-03-13T00:00:00&#43;00:00" />
<meta property="og:see_also" content="https://lambertxiao.github.io/posts/gdb_usage/doc/" /><meta property="og:see_also" content="https://lambertxiao.github.io/posts/numa/doc/" /><meta property="og:see_also" content="https://lambertxiao.github.io/posts/uio/doc/" /><meta property="og:see_also" content="https://lambertxiao.github.io/posts/vfio/doc/" /><meta property="og:see_also" content="https://lambertxiao.github.io/posts/virtio/doc/" /><meta property="og:see_also" content="https://lambertxiao.github.io/posts/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/doc/" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://lambertxiao.github.io/papermod-cover.png"/>

<meta name="twitter:title" content="算法-链表"/>
<meta name="twitter:description" content="2. 两数相加 2. 两数相加
给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
206. 反转链表 206. 反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
func reverseList(head *ListNode) *ListNode { // 双指针，pre和curr一前一后  var pre *ListNode curr := head for curr != nil { tmp := curr.Next curr.Next = pre pre = curr curr = tmp } return pre } func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } nhead := reverseList(head."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://lambertxiao.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "算法-链表",
      "item": "https://lambertxiao.github.io/posts/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/doc/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "算法-链表",
  "name": "算法-链表",
  "description": "2. 两数相加 2. 两数相加\n给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n206. 反转链表 206. 反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\nfunc reverseList(head *ListNode) *ListNode { // 双指针，pre和curr一前一后  var pre *ListNode curr := head for curr != nil { tmp := curr.Next curr.Next = pre pre = curr curr = tmp } return pre } func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } nhead := reverseList(head.",
  "keywords": [
    "算法"
  ],
  "articleBody": "2. 两数相加 2. 两数相加\n给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n206. 反转链表 206. 反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\nfunc reverseList(head *ListNode) *ListNode { // 双指针，pre和curr一前一后  var pre *ListNode curr := head for curr != nil { tmp := curr.Next curr.Next = pre pre = curr curr = tmp } return pre } func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } nhead := reverseList(head.Next) head.Next.Next = head // 先指向回自己建立联系  head.Next = nil // 再把多余的联系断掉  return nhead } 19. 删除链表的倒数第 N 个结点 19. 删除链表的倒数第 N 个结点\n给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode { // 快慢指针  dummy := \u0026ListNode{} dummy.Next = head s, f := dummy, dummy // faster向前走n+1步，一会可以让slow停在想要删除的节点的前继节点上  for n = 0 \u0026\u0026 f != nil { f = f.Next n-- } for f != nil { f = f.Next s = s.Next } s.Next = s.Next.Next return dummy.Next } 23. 合并K个升序链表 23. 合并K个升序链表\n给你一个链表数组，每个链表都已经按升序排列。\n请你将所有链表合并到一个升序链表中，返回合并后的链表。\nfunc mergeKLists(lists []*ListNode) *ListNode { h := hp{} for _, node := range lists { if node != nil { heap.Push(\u0026h, node) } } dummy := \u0026ListNode{} curr := dummy for len(h) != 0 { node := heap.Pop(\u0026h).(*ListNode) curr.Next = node curr = curr.Next if node.Next != nil { heap.Push(\u0026h, node.Next) } } return dummy.Next } type hp []*ListNode func (h hp) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h hp) Less(i, j int) bool { return h[i].Val func (h hp) Len() int { return len(h) } func (h *hp) Push(x interface{}) { *h = append(*h, x.(*ListNode))} func (h *hp) Pop() interface{} { old := *h n := len(old) e := old[n-1] *h = old[:n-1] return e } 21. 合并两个有序链表 21. 合并两个有序链表\n将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\nfunc mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode { if list1 == nil { return list2 } if list2 == nil { return list1 } if list1.Val return list1 } list2.Next = mergeTwoLists(list2.Next, list1) return list2 } 24. 两两交换链表中的节点 24. 两两交换链表中的节点\n给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\nfunc swapPairs(head *ListNode) *ListNode { // 递归法：明确swapPairs的含义就是将给定的链表两两反转  if head == nil || head.Next == nil { return head } // 将当前节点和后继节点反转  next := head.Next // 除了第一个第二个节点外的节点继续去做递归反转，并接到head后面  head.Next = swapPairs(next.Next) // 反转head和next  next.Next = head return next } 25. K 个一组翻转链表 25. K 个一组翻转链表\n给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。\nk 是一个正整数，它的值小于或等于链表的长度。\n如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n进阶：\n你可以设计一个只使用常数额外空间的算法来解决此问题吗？ 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\nfunc reverseKGroup(head *ListNode, k int) *ListNode { start, end := head, head for i := 0; i ++ { if end == nil { return head // 不足k个  } end = end.Next } newHead := reverse(start, end) start.Next = reverseKGroup(end, k) return newHead } func reverse(start *ListNode, end *ListNode) *ListNode { var pre *ListNode curr := start for curr != end { t := curr.Next curr.Next = pre pre = curr curr = t } return pre } 234. 回文链表 234. 回文链表 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。\nfunc isPalindrome(head *ListNode) bool { slow, faster := head, head for faster != nil \u0026\u0026 faster.Next != nil { slow = slow.Next faster = faster.Next.Next } left := head right := reverse(slow) for left != nil \u0026\u0026 right != nil { if left.Val != right.Val { return false } left = left.Next right = right.Next } return true } func reverse(head *ListNode) *ListNode { var pre *ListNode for head != nil { next := head.Next head.Next = pre pre = head head = next } return pre } 160. 相交链表 160. 相交链表 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } pa, pb := headA, headB for pa != pb { if pa == nil { pa = headB } else { pa = pa.Next } if pb == nil { pb = headA } else { pb = pb.Next } } return pa } 141. 环形链表 141. 环形链表 给你一个链表的头节点 head ，判断链表中是否有环。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。\n如果链表中存在环 ，则返回 true 。 否则，返回 false 。\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func hasCycle(head *ListNode) bool { s, f := head, head for f != nil { if f.Next == nil { return false } f = f.Next.Next s = s.Next if s == f { return true } } return false } 142. 环形链表 II 142. 环形链表 II 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n不允许修改 链表。\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func detectCycle(head *ListNode) *ListNode { // 设链表共有a+b个节点  // fast = 2 * slow, fast = slow + nb =  slow = nb  // 到达环的时候走过的距离为 = a + nb, 所以就是求a，就是在当前s的位置再走a步  f, s := head, head for f != nil { if f.Next == nil { return nil } f = f.Next.Next s = s.Next if f == s { break } } if f == nil { return nil } // f走过的距离为2倍的s，并且相遇时f走过了s + nb的距离  // 让head，slow指针各走a步，去汇合  for head != nil { if head == s { return head } head = head.Next s = s.Next } return nil } 148. 排序链表 148. 排序链表 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。\nfunc sortList(head *ListNode) *ListNode { return sort(head, nil) } func sort(head *ListNode, tail *ListNode) *ListNode { if head == nil { return nil } if head.Next == tail { head.Next = nil return head } mid := findMid(head, tail) return merge(sort(head, mid), sort(mid, tail)) } // 将排好序的链表合并 func merge(l1 *ListNode, l2 *ListNode) *ListNode { dummy := \u0026ListNode{} curr := dummy for l1 != nil || l2 != nil { if l1 == nil { curr.Next = l2 l2 = l2.Next } else if l2 == nil { curr.Next = l1 l1 = l1.Next } else if l1.Val else { curr.Next = l2 l2 = l2.Next } curr = curr.Next } return dummy.Next } // 找链表的中点 func findMid(head *ListNode, tail *ListNode) *ListNode { s, f := head, head for f != tail \u0026\u0026 f.Next != tail { f = f.Next.Next s = s.Next } return s } 剑指 Offer 22. 链表中倒数第k个节点 剑指 Offer 22. 链表中倒数第k个节点 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。\n例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func getKthFromEnd(head *ListNode, k int) *ListNode { if head == nil { return nil } p, q := head, head i := 0 for i if q == nil { break } q = q.Next i++ } if i return nil } for q != nil { p = p.Next q = q.Next } return p } 重排链表 143. 重排链表 给定一个单链表 L 的头节点 head ，单链表 L 表示为：\nL0 → L1 → … → Ln - 1 → Ln 请将其重新排列后变为：\nL0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reorderList(head *ListNode) { if head == nil { return } mid := middleNode(head) nhead := reverseList(mid.Next) mid.Next = nil // 断掉  mergeList(head, nhead) return } func mergeList(l1, l2 *ListNode) { for l1 != nil \u0026\u0026 l2 != nil { t1 := l1.Next t2 := l2.Next l1.Next = l2 l1 = t1 l2.Next = t1 l2 = t2 } } func middleNode(head *ListNode) *ListNode { f, s := head, head for f != nil \u0026\u0026 f.Next != nil { f = f.Next.Next s = s.Next } return s } func reverseList(head *ListNode) *ListNode { if head == nil { return nil } var pre *ListNode curr := head for curr != nil { t := curr.Next curr.Next = pre pre = curr curr = t } return pre } 138. 复制带随机指针的链表 138. 复制带随机指针的链表 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。\n构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。\n例如，如果原链表中有 X 和 Y 两个节点，其中 X.random – Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random – y 。\n返回复制链表的头节点。\n用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：\nval：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。 你的代码 只 接受原链表的头节点 head 作为传入参数。\n/** * Definition for a Node. * type Node struct { * Val int * Next *Node * Random *Node * } */ func copyRandomList(head *Node) *Node { curr := head // 很妙的解法，原先A-B-C，先复制一份节点为A-A'-B-B'-C-C'  for curr != nil { curr.Next = \u0026Node{Val: curr.Val, Next: curr.Next} curr = curr.Next.Next } curr = head // 接上random节点  for curr != nil { // 如果原先节点存在random节点  if curr.Random != nil { // 新的random节点一定在原先的random节点后面  curr.Next.Random = curr.Random.Next } curr = curr.Next.Next } dummy := \u0026Node{} ncurr := dummy // 将链表拆分  curr = head for curr != nil { ncurr.Next = curr.Next ncurr = ncurr.Next curr.Next = curr.Next.Next curr = curr.Next } return dummy.Next } 328. 奇偶链表 328. 奇偶链表 给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。\n第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。\n请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。\n你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func oddEvenList(head *ListNode) *ListNode { if head == nil { return nil } odd, even := head, head.Next eventHead := even for even != nil \u0026\u0026 even.Next != nil { odd.Next = even.Next odd = odd.Next even.Next = odd.Next even = even.Next } odd.Next = eventHead return head } 83. 删除排序链表中的重复元素 83. 删除排序链表中的重复元素 给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func deleteDuplicates(head *ListNode) *ListNode { if head == nil { return nil } curr := head for curr.Next != nil { if curr.Val == curr.Next.Val { curr.Next = curr.Next.Next } else { curr = curr.Next } } return head } 82. 删除排序链表中的重复元素 II 82. 删除排序链表中的重复元素 II 给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func deleteDuplicates(head *ListNode) *ListNode { dummy := \u0026ListNode{Val: -101} dummy.Next = head curr := dummy for curr.Next != nil \u0026\u0026 curr.Next.Next != nil { if curr.Next.Val == curr.Next.Next.Val { x := curr.Next.Val for curr.Next != nil \u0026\u0026 curr.Next.Val == x { curr.Next = curr.Next.Next } } else { curr = curr.Next } } return dummy.Next } ",
  "wordCount" : "1746",
  "inLanguage": "en",
  "datePublished": "2022-03-13T00:00:00Z",
  "dateModified": "2022-03-13T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Lambert Xiao"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lambertxiao.github.io/posts/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/doc/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Lambert's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lambertxiao.github.io/avatar.jpeg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lambertxiao.github.io" accesskey="h" title="Lambert&#39;s Blog (Alt + H)">
                <img src="https://lambertxiao.github.io/avatar.jpeg" alt="logo" aria-label="logo"
                    height="35">Lambert&#39;s Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lambertxiao.github.io/archives" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="https://lambertxiao.github.io/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="https://lambertxiao.github.io/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://lambertxiao.github.io">Home</a>&nbsp;»&nbsp;<a href="https://lambertxiao.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      算法-链表
    </h1>
    <div class="post-meta"><span title='2022-03-13 00:00:00 +0000 UTC'>March 13, 2022</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Lambert Xiao&nbsp;|&nbsp;<a href="https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content/posts/%e7%ae%97%e6%b3%95/%e7%ae%97%e6%b3%95-%e9%93%be%e8%a1%a8/doc.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#2-%e4%b8%a4%e6%95%b0%e7%9b%b8%e5%8a%a0" aria-label="2. 两数相加">2. 两数相加</a></li>
                <li>
                    <a href="#206-%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8" aria-label="206. 反转链表">206. 反转链表</a></li>
                <li>
                    <a href="#19-%e5%88%a0%e9%99%a4%e9%93%be%e8%a1%a8%e7%9a%84%e5%80%92%e6%95%b0%e7%ac%ac-n-%e4%b8%aa%e7%bb%93%e7%82%b9" aria-label="19. 删除链表的倒数第 N 个结点">19. 删除链表的倒数第 N 个结点</a></li>
                <li>
                    <a href="#23-%e5%90%88%e5%b9%b6k%e4%b8%aa%e5%8d%87%e5%ba%8f%e9%93%be%e8%a1%a8" aria-label="23. 合并K个升序链表">23. 合并K个升序链表</a></li>
                <li>
                    <a href="#21-%e5%90%88%e5%b9%b6%e4%b8%a4%e4%b8%aa%e6%9c%89%e5%ba%8f%e9%93%be%e8%a1%a8" aria-label="21. 合并两个有序链表">21. 合并两个有序链表</a></li>
                <li>
                    <a href="#24-%e4%b8%a4%e4%b8%a4%e4%ba%a4%e6%8d%a2%e9%93%be%e8%a1%a8%e4%b8%ad%e7%9a%84%e8%8a%82%e7%82%b9" aria-label="24. 两两交换链表中的节点">24. 两两交换链表中的节点</a></li>
                <li>
                    <a href="#25-k-%e4%b8%aa%e4%b8%80%e7%bb%84%e7%bf%bb%e8%bd%ac%e9%93%be%e8%a1%a8" aria-label="25. K 个一组翻转链表">25. K 个一组翻转链表</a></li>
                <li>
                    <a href="#234-%e5%9b%9e%e6%96%87%e9%93%be%e8%a1%a8" aria-label="234. 回文链表">234. 回文链表</a></li>
                <li>
                    <a href="#160-%e7%9b%b8%e4%ba%a4%e9%93%be%e8%a1%a8" aria-label="160. 相交链表">160. 相交链表</a></li>
                <li>
                    <a href="#141-%e7%8e%af%e5%bd%a2%e9%93%be%e8%a1%a8" aria-label="141. 环形链表">141. 环形链表</a></li>
                <li>
                    <a href="#142-%e7%8e%af%e5%bd%a2%e9%93%be%e8%a1%a8-ii" aria-label="142. 环形链表 II">142. 环形链表 II</a></li>
                <li>
                    <a href="#148-%e6%8e%92%e5%ba%8f%e9%93%be%e8%a1%a8" aria-label="148. 排序链表">148. 排序链表</a></li>
                <li>
                    <a href="#%e5%89%91%e6%8c%87-offer-22-%e9%93%be%e8%a1%a8%e4%b8%ad%e5%80%92%e6%95%b0%e7%ac%ack%e4%b8%aa%e8%8a%82%e7%82%b9" aria-label="剑指 Offer 22. 链表中倒数第k个节点">剑指 Offer 22. 链表中倒数第k个节点</a></li>
                <li>
                    <a href="#%e9%87%8d%e6%8e%92%e9%93%be%e8%a1%a8" aria-label="重排链表">重排链表</a></li>
                <li>
                    <a href="#138-%e5%a4%8d%e5%88%b6%e5%b8%a6%e9%9a%8f%e6%9c%ba%e6%8c%87%e9%92%88%e7%9a%84%e9%93%be%e8%a1%a8" aria-label="138. 复制带随机指针的链表">138. 复制带随机指针的链表</a></li>
                <li>
                    <a href="#328-%e5%a5%87%e5%81%b6%e9%93%be%e8%a1%a8" aria-label="328. 奇偶链表">328. 奇偶链表</a></li>
                <li>
                    <a href="#83-%e5%88%a0%e9%99%a4%e6%8e%92%e5%ba%8f%e9%93%be%e8%a1%a8%e4%b8%ad%e7%9a%84%e9%87%8d%e5%a4%8d%e5%85%83%e7%b4%a0" aria-label="83. 删除排序链表中的重复元素">83. 删除排序链表中的重复元素</a></li>
                <li>
                    <a href="#82-%e5%88%a0%e9%99%a4%e6%8e%92%e5%ba%8f%e9%93%be%e8%a1%a8%e4%b8%ad%e7%9a%84%e9%87%8d%e5%a4%8d%e5%85%83%e7%b4%a0-ii" aria-label="82. 删除排序链表中的重复元素 II">82. 删除排序链表中的重复元素 II</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="2-两数相加">2. 两数相加<a hidden class="anchor" aria-hidden="true" href="#2-两数相加">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></p>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。
你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<h3 id="206-反转链表">206. 反转链表<a hidden class="anchor" aria-hidden="true" href="#206-反转链表">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a>
给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00cd00">func</span> reverseList(head <span style="color:#39c">*</span>ListNode) <span style="color:#39c">*</span>ListNode {
    <span style="color:#000080">// 双指针，pre和curr一前一后
</span><span style="color:#000080"></span>    <span style="color:#00cd00">var</span> pre <span style="color:#39c">*</span>ListNode
    curr <span style="color:#39c">:=</span> head

    <span style="color:#cdcd00">for</span> curr <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        tmp <span style="color:#39c">:=</span> curr.Next
        curr.Next = pre
        pre = curr
        curr = tmp
    }

    <span style="color:#cdcd00">return</span> pre
}

<span style="color:#00cd00">func</span> reverseList(head <span style="color:#39c">*</span>ListNode) <span style="color:#39c">*</span>ListNode {
    <span style="color:#cdcd00">if</span> head <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> <span style="color:#39c">||</span> head.Next <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> head
    }

    nhead <span style="color:#39c">:=</span> reverseList(head.Next)
    head.Next.Next = head <span style="color:#000080">// 先指向回自己建立联系
</span><span style="color:#000080"></span>    head.Next = <span style="color:#cdcd00">nil</span> <span style="color:#000080">// 再把多余的联系断掉
</span><span style="color:#000080"></span>
    <span style="color:#cdcd00">return</span> nhead
}
</code></pre></div><h3 id="19-删除链表的倒数第-n-个结点">19. 删除链表的倒数第 N 个结点<a hidden class="anchor" aria-hidden="true" href="#19-删除链表的倒数第-n-个结点">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></p>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00cd00">func</span> removeNthFromEnd(head <span style="color:#39c">*</span>ListNode, n <span style="color:#00cd00">int</span>) <span style="color:#39c">*</span>ListNode {
    <span style="color:#000080">// 快慢指针
</span><span style="color:#000080"></span>    dummy <span style="color:#39c">:=</span> <span style="color:#39c">&amp;</span>ListNode{}
    dummy.Next = head
    s, f <span style="color:#39c">:=</span> dummy, dummy

    <span style="color:#000080">// faster向前走n+1步，一会可以让slow停在想要删除的节点的前继节点上
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">for</span> n <span style="color:#39c">&gt;=</span> <span style="color:#cd00cd">0</span> <span style="color:#39c">&amp;&amp;</span> f <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        f = f.Next
        n<span style="color:#39c">--</span>
    }

    <span style="color:#cdcd00">for</span> f <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        f = f.Next
        s = s.Next
    }

    s.Next = s.Next.Next
    <span style="color:#cdcd00">return</span> dummy.Next
}
</code></pre></div><h3 id="23-合并k个升序链表">23. 合并K个升序链表<a hidden class="anchor" aria-hidden="true" href="#23-合并k个升序链表">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></p>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00cd00">func</span> mergeKLists(lists []<span style="color:#39c">*</span>ListNode) <span style="color:#39c">*</span>ListNode {
    h <span style="color:#39c">:=</span> hp{}
    <span style="color:#cdcd00">for</span> _, node <span style="color:#39c">:=</span> <span style="color:#cdcd00">range</span> lists {
        <span style="color:#cdcd00">if</span> node <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
            heap.Push(<span style="color:#39c">&amp;</span>h, node)
        }
    }

    dummy <span style="color:#39c">:=</span> <span style="color:#39c">&amp;</span>ListNode{}
    curr <span style="color:#39c">:=</span> dummy
    <span style="color:#cdcd00">for</span> <span style="color:#cd00cd">len</span>(h) <span style="color:#39c">!=</span> <span style="color:#cd00cd">0</span> {
        node <span style="color:#39c">:=</span> heap.Pop(<span style="color:#39c">&amp;</span>h).(<span style="color:#39c">*</span>ListNode)
        curr.Next = node
        curr = curr.Next
        
        <span style="color:#cdcd00">if</span> node.Next <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
            heap.Push(<span style="color:#39c">&amp;</span>h, node.Next)
        }
    }
    <span style="color:#cdcd00">return</span> dummy.Next
}

<span style="color:#00cd00">type</span> hp []<span style="color:#39c">*</span>ListNode

<span style="color:#00cd00">func</span> (h hp) Swap(i, j <span style="color:#00cd00">int</span>) { h[i], h[j] = h[j], h[i] }
<span style="color:#00cd00">func</span> (h hp) Less(i, j <span style="color:#00cd00">int</span>) <span style="color:#00cd00">bool</span> { <span style="color:#cdcd00">return</span> h[i].Val &lt; h[j].Val }
<span style="color:#00cd00">func</span> (h hp) Len() <span style="color:#00cd00">int</span> { <span style="color:#cdcd00">return</span> <span style="color:#cd00cd">len</span>(h) }
<span style="color:#00cd00">func</span> (h <span style="color:#39c">*</span>hp) Push(x <span style="color:#00cd00">interface</span>{}) { <span style="color:#39c">*</span>h = <span style="color:#cd00cd">append</span>(<span style="color:#39c">*</span>h, x.(<span style="color:#39c">*</span>ListNode))}
<span style="color:#00cd00">func</span> (h <span style="color:#39c">*</span>hp) Pop() <span style="color:#00cd00">interface</span>{} {
    old <span style="color:#39c">:=</span> <span style="color:#39c">*</span>h
    n <span style="color:#39c">:=</span> <span style="color:#cd00cd">len</span>(old)
    e <span style="color:#39c">:=</span> old[n<span style="color:#39c">-</span><span style="color:#cd00cd">1</span>]
    <span style="color:#39c">*</span>h = old[:n<span style="color:#39c">-</span><span style="color:#cd00cd">1</span>]
    <span style="color:#cdcd00">return</span> e
}
</code></pre></div><h3 id="21-合并两个有序链表">21. 合并两个有序链表<a hidden class="anchor" aria-hidden="true" href="#21-合并两个有序链表">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></p>
<p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00cd00">func</span> mergeTwoLists(list1 <span style="color:#39c">*</span>ListNode, list2 <span style="color:#39c">*</span>ListNode) <span style="color:#39c">*</span>ListNode {
    <span style="color:#cdcd00">if</span> list1 <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> list2
    }
    <span style="color:#cdcd00">if</span> list2 <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> list1
    }
    <span style="color:#cdcd00">if</span> list1.Val &lt; list2.Val {
        list1.Next = mergeTwoLists(list1.Next, list2)
        <span style="color:#cdcd00">return</span> list1
    }

    list2.Next = mergeTwoLists(list2.Next, list1)
    <span style="color:#cdcd00">return</span> list2
}
</code></pre></div><h3 id="24-两两交换链表中的节点">24. 两两交换链表中的节点<a hidden class="anchor" aria-hidden="true" href="#24-两两交换链表中的节点">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></p>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00cd00">func</span> swapPairs(head <span style="color:#39c">*</span>ListNode) <span style="color:#39c">*</span>ListNode {
    <span style="color:#000080">// 递归法：明确swapPairs的含义就是将给定的链表两两反转
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">if</span> head <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> <span style="color:#39c">||</span> head.Next <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> head
    }

    <span style="color:#000080">// 将当前节点和后继节点反转
</span><span style="color:#000080"></span>    next <span style="color:#39c">:=</span> head.Next
    <span style="color:#000080">// 除了第一个第二个节点外的节点继续去做递归反转，并接到head后面
</span><span style="color:#000080"></span>    head.Next = swapPairs(next.Next)
    <span style="color:#000080">// 反转head和next
</span><span style="color:#000080"></span>    next.Next = head
    <span style="color:#cdcd00">return</span> next
}
</code></pre></div><h3 id="25-k-个一组翻转链表">25. K 个一组翻转链表<a hidden class="anchor" aria-hidden="true" href="#25-k-个一组翻转链表">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></p>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>进阶：</p>
<p>你可以设计一个只使用常数额外空间的算法来解决此问题吗？
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00cd00">func</span> reverseKGroup(head <span style="color:#39c">*</span>ListNode, k <span style="color:#00cd00">int</span>) <span style="color:#39c">*</span>ListNode {
    start, end <span style="color:#39c">:=</span> head, head
    <span style="color:#cdcd00">for</span> i <span style="color:#39c">:=</span> <span style="color:#cd00cd">0</span>; i &lt; k; i<span style="color:#39c">++</span> {
        <span style="color:#cdcd00">if</span> end <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
            <span style="color:#cdcd00">return</span> head <span style="color:#000080">// 不足k个
</span><span style="color:#000080"></span>        }
        end = end.Next
    }

    newHead <span style="color:#39c">:=</span> reverse(start, end)
    start.Next = reverseKGroup(end, k)

    <span style="color:#cdcd00">return</span> newHead
}

<span style="color:#00cd00">func</span> reverse(start <span style="color:#39c">*</span>ListNode, end <span style="color:#39c">*</span>ListNode) <span style="color:#39c">*</span>ListNode {
    <span style="color:#00cd00">var</span> pre <span style="color:#39c">*</span>ListNode
    curr <span style="color:#39c">:=</span> start
    <span style="color:#cdcd00">for</span> curr <span style="color:#39c">!=</span> end {
        t <span style="color:#39c">:=</span> curr.Next
        curr.Next = pre
        pre = curr
        curr = t
    }
    <span style="color:#cdcd00">return</span> pre
}
</code></pre></div><h3 id="234-回文链表">234. 回文链表<a hidden class="anchor" aria-hidden="true" href="#234-回文链表">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a>
给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00cd00">func</span> isPalindrome(head <span style="color:#39c">*</span>ListNode) <span style="color:#00cd00">bool</span> {
    slow, faster <span style="color:#39c">:=</span> head, head

    <span style="color:#cdcd00">for</span> faster <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> <span style="color:#39c">&amp;&amp;</span> faster.Next <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        slow = slow.Next
        faster = faster.Next.Next
    }

    left <span style="color:#39c">:=</span> head 
    right <span style="color:#39c">:=</span> reverse(slow)

    <span style="color:#cdcd00">for</span> left <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> <span style="color:#39c">&amp;&amp;</span> right <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">if</span> left.Val <span style="color:#39c">!=</span> right.Val {
            <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">false</span>
        }
        left = left.Next
        right = right.Next
    }
    <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">true</span>
}

<span style="color:#00cd00">func</span> reverse(head <span style="color:#39c">*</span>ListNode) <span style="color:#39c">*</span>ListNode {
    <span style="color:#00cd00">var</span> pre <span style="color:#39c">*</span>ListNode
    
    <span style="color:#cdcd00">for</span> head <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        next <span style="color:#39c">:=</span> head.Next
        head.Next = pre
        pre = head
        head = next
    }

    <span style="color:#cdcd00">return</span> pre
}
</code></pre></div><h3 id="160-相交链表">160. 相交链表<a hidden class="anchor" aria-hidden="true" href="#160-相交链表">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a>
给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00cd00">func</span> getIntersectionNode(headA, headB <span style="color:#39c">*</span>ListNode) <span style="color:#39c">*</span>ListNode {
    <span style="color:#cdcd00">if</span> headA <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> <span style="color:#39c">||</span> headB <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> { <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span> }
    pa, pb <span style="color:#39c">:=</span> headA, headB

    <span style="color:#cdcd00">for</span> pa <span style="color:#39c">!=</span> pb {
        <span style="color:#cdcd00">if</span> pa <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
            pa = headB
        } <span style="color:#cdcd00">else</span> {
            pa = pa.Next
        }

        <span style="color:#cdcd00">if</span> pb <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
            pb = headA
        } <span style="color:#cdcd00">else</span> {
            pb = pb.Next
        }
    }
    <span style="color:#cdcd00">return</span> pa
}
</code></pre></div><h3 id="141-环形链表">141. 环形链表<a hidden class="anchor" aria-hidden="true" href="#141-环形链表">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a>
给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for singly-linked list.
</span><span style="color:#000080"> * type ListNode struct {
</span><span style="color:#000080"> *     Val int
</span><span style="color:#000080"> *     Next *ListNode
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>
<span style="color:#00cd00">func</span> hasCycle(head <span style="color:#39c">*</span>ListNode) <span style="color:#00cd00">bool</span> {
    s, f <span style="color:#39c">:=</span> head, head

    <span style="color:#cdcd00">for</span> f <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">if</span> f.Next <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
            <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">false</span>
        }
        f = f.Next.Next
        s = s.Next
        
        <span style="color:#cdcd00">if</span> s <span style="color:#39c">==</span> f {
            <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">true</span>
        }
    }
    <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">false</span>
}
</code></pre></div><h3 id="142-环形链表-ii">142. 环形链表 II<a hidden class="anchor" aria-hidden="true" href="#142-环形链表-ii">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a>
给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for singly-linked list.
</span><span style="color:#000080"> * type ListNode struct {
</span><span style="color:#000080"> *     Val int
</span><span style="color:#000080"> *     Next *ListNode
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>
<span style="color:#00cd00">func</span> detectCycle(head <span style="color:#39c">*</span>ListNode) <span style="color:#39c">*</span>ListNode {
    <span style="color:#000080">// 设链表共有a+b个节点
</span><span style="color:#000080"></span>    <span style="color:#000080">// fast = 2 * slow, fast = slow + nb = &gt; slow = nb
</span><span style="color:#000080"></span>    <span style="color:#000080">// 到达环的时候走过的距离为 = a + nb, 所以就是求a，就是在当前s的位置再走a步
</span><span style="color:#000080"></span>
    f, s <span style="color:#39c">:=</span> head, head

    <span style="color:#cdcd00">for</span> f <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">if</span> f.Next <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
            <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>
        }

        f = f.Next.Next
        s = s.Next

        <span style="color:#cdcd00">if</span> f <span style="color:#39c">==</span> s {
            <span style="color:#cdcd00">break</span>
        }
    }
    <span style="color:#cdcd00">if</span> f <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>
    }

    <span style="color:#000080">// f走过的距离为2倍的s，并且相遇时f走过了s + nb的距离
</span><span style="color:#000080"></span>    <span style="color:#000080">// 让head，slow指针各走a步，去汇合
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">for</span> head <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">if</span> head <span style="color:#39c">==</span> s {
            <span style="color:#cdcd00">return</span> head
        }

        head = head.Next 
        s = s.Next
    }
    <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>
}
</code></pre></div><h3 id="148-排序链表">148. 排序链表<a hidden class="anchor" aria-hidden="true" href="#148-排序链表">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a>
给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00cd00">func</span> sortList(head <span style="color:#39c">*</span>ListNode) <span style="color:#39c">*</span>ListNode {
    <span style="color:#cdcd00">return</span> sort(head, <span style="color:#cdcd00">nil</span>)
}

<span style="color:#00cd00">func</span> sort(head <span style="color:#39c">*</span>ListNode, tail <span style="color:#39c">*</span>ListNode) <span style="color:#39c">*</span>ListNode {
    <span style="color:#cdcd00">if</span> head <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>
    }
    <span style="color:#cdcd00">if</span> head.Next <span style="color:#39c">==</span> tail {
        head.Next = <span style="color:#cdcd00">nil</span>
        <span style="color:#cdcd00">return</span> head
    }

    mid <span style="color:#39c">:=</span> findMid(head, tail)
    <span style="color:#cdcd00">return</span> merge(sort(head, mid), sort(mid, tail))
}

<span style="color:#000080">// 将排好序的链表合并
</span><span style="color:#000080"></span><span style="color:#00cd00">func</span> merge(l1 <span style="color:#39c">*</span>ListNode, l2 <span style="color:#39c">*</span>ListNode) <span style="color:#39c">*</span>ListNode {
    dummy <span style="color:#39c">:=</span> <span style="color:#39c">&amp;</span>ListNode{}
    curr <span style="color:#39c">:=</span> dummy

    <span style="color:#cdcd00">for</span> l1 <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> <span style="color:#39c">||</span> l2 <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">if</span> l1 <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
            curr.Next = l2
            l2 = l2.Next
        } <span style="color:#cdcd00">else</span> <span style="color:#cdcd00">if</span> l2 <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
            curr.Next = l1
            l1 = l1.Next
        } <span style="color:#cdcd00">else</span> <span style="color:#cdcd00">if</span> l1.Val &lt; l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } <span style="color:#cdcd00">else</span> {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }
    <span style="color:#cdcd00">return</span> dummy.Next
}

<span style="color:#000080">// 找链表的中点
</span><span style="color:#000080"></span><span style="color:#00cd00">func</span> findMid(head <span style="color:#39c">*</span>ListNode, tail <span style="color:#39c">*</span>ListNode) <span style="color:#39c">*</span>ListNode {
    s, f <span style="color:#39c">:=</span> head, head
    <span style="color:#cdcd00">for</span> f <span style="color:#39c">!=</span> tail <span style="color:#39c">&amp;&amp;</span> f.Next <span style="color:#39c">!=</span> tail {
        f = f.Next.Next
        s = s.Next
    }

    <span style="color:#cdcd00">return</span> s
}
</code></pre></div><h3 id="剑指-offer-22-链表中倒数第k个节点">剑指 Offer 22. 链表中倒数第k个节点<a hidden class="anchor" aria-hidden="true" href="#剑指-offer-22-链表中倒数第k个节点">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a>
输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>
<p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for singly-linked list.
</span><span style="color:#000080"> * type ListNode struct {
</span><span style="color:#000080"> *     Val int
</span><span style="color:#000080"> *     Next *ListNode
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>
<span style="color:#00cd00">func</span> getKthFromEnd(head <span style="color:#39c">*</span>ListNode, k <span style="color:#00cd00">int</span>) <span style="color:#39c">*</span>ListNode {
    <span style="color:#cdcd00">if</span> head <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>
    }
    
    p, q <span style="color:#39c">:=</span> head, head
    i <span style="color:#39c">:=</span> <span style="color:#cd00cd">0</span>

    <span style="color:#cdcd00">for</span> i &lt; k {
        <span style="color:#cdcd00">if</span> q <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
            <span style="color:#cdcd00">break</span>
        }
        q = q.Next
        i<span style="color:#39c">++</span>
    }

    <span style="color:#cdcd00">if</span> i &lt; k {
        <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>
    }

    <span style="color:#cdcd00">for</span> q <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        p = p.Next
        q = q.Next
    }

    <span style="color:#cdcd00">return</span> p
}
</code></pre></div><h3 id="重排链表">重排链表<a hidden class="anchor" aria-hidden="true" href="#重排链表">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/reorder-list/">143. 重排链表</a>
给定一个单链表 L 的头节点 head ，单链表 L 表示为：</p>
<p>L0 → L1 → … → Ln - 1 → Ln
请将其重新排列后变为：</p>
<p>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for singly-linked list.
</span><span style="color:#000080"> * type ListNode struct {
</span><span style="color:#000080"> *     Val int
</span><span style="color:#000080"> *     Next *ListNode
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>
<span style="color:#00cd00">func</span> reorderList(head <span style="color:#39c">*</span>ListNode) {
    <span style="color:#cdcd00">if</span> head <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span>
    }
    mid <span style="color:#39c">:=</span> middleNode(head)
    nhead <span style="color:#39c">:=</span> reverseList(mid.Next)
    mid.Next = <span style="color:#cdcd00">nil</span> <span style="color:#000080">// 断掉
</span><span style="color:#000080"></span>    mergeList(head, nhead)
    <span style="color:#cdcd00">return</span> 
}

<span style="color:#00cd00">func</span> mergeList(l1, l2 <span style="color:#39c">*</span>ListNode) {
    <span style="color:#cdcd00">for</span> l1 <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> <span style="color:#39c">&amp;&amp;</span> l2 <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        t1 <span style="color:#39c">:=</span> l1.Next
        t2 <span style="color:#39c">:=</span> l2.Next

        l1.Next = l2
        l1 = t1

        l2.Next = t1
        l2 = t2
    }
}

<span style="color:#00cd00">func</span> middleNode(head <span style="color:#39c">*</span>ListNode) <span style="color:#39c">*</span>ListNode {
    f, s <span style="color:#39c">:=</span> head, head
    <span style="color:#cdcd00">for</span> f <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> <span style="color:#39c">&amp;&amp;</span> f.Next <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        f = f.Next.Next
        s = s.Next
    }
    <span style="color:#cdcd00">return</span> s
}

<span style="color:#00cd00">func</span> reverseList(head <span style="color:#39c">*</span>ListNode) <span style="color:#39c">*</span>ListNode {
    <span style="color:#cdcd00">if</span> head <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>
    }
    <span style="color:#00cd00">var</span> pre <span style="color:#39c">*</span>ListNode
    curr <span style="color:#39c">:=</span> head

    <span style="color:#cdcd00">for</span> curr <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        t <span style="color:#39c">:=</span> curr.Next
        curr.Next = pre
        pre = curr
        curr = t
    }
    <span style="color:#cdcd00">return</span> pre
}
</code></pre></div><h3 id="138-复制带随机指针的链表">138. 复制带随机指针的链表<a hidden class="anchor" aria-hidden="true" href="#138-复制带随机指针的链表">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">138. 复制带随机指针的链表</a>
给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</p>
<p>构造这个链表的 <a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a>。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p>
<p>例如，如果原链表中有 X 和 Y 两个节点，其中 X.random &ndash;&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random &ndash;&gt; y 。</p>
<p>返回复制链表的头节点。</p>
<p>用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p>
<p>val：一个表示 Node.val 的整数。
random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。
你的代码 只 接受原链表的头节点 head 作为传入参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for a Node.
</span><span style="color:#000080"> * type Node struct {
</span><span style="color:#000080"> *     Val int
</span><span style="color:#000080"> *     Next *Node
</span><span style="color:#000080"> *     Random *Node
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>

<span style="color:#00cd00">func</span> copyRandomList(head <span style="color:#39c">*</span>Node) <span style="color:#39c">*</span>Node {
    curr <span style="color:#39c">:=</span> head
    <span style="color:#000080">// 很妙的解法，原先A-&gt;B-&gt;C，先复制一份节点为A-&gt;A&#39;-&gt;B-&gt;B&#39;-&gt;C-&gt;C&#39;
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">for</span> curr <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        curr.Next = <span style="color:#39c">&amp;</span>Node{Val: curr.Val, Next: curr.Next}
        curr = curr.Next.Next
    }
    curr = head
    <span style="color:#000080">// 接上random节点
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">for</span> curr <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#000080">// 如果原先节点存在random节点
</span><span style="color:#000080"></span>        <span style="color:#cdcd00">if</span> curr.Random <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
            <span style="color:#000080">// 新的random节点一定在原先的random节点后面
</span><span style="color:#000080"></span>            curr.Next.Random = curr.Random.Next
        }
        curr = curr.Next.Next
    }

    dummy <span style="color:#39c">:=</span> <span style="color:#39c">&amp;</span>Node{}
    ncurr <span style="color:#39c">:=</span> dummy
    <span style="color:#000080">// 将链表拆分
</span><span style="color:#000080"></span>    curr = head
    <span style="color:#cdcd00">for</span> curr <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        ncurr.Next = curr.Next
        ncurr = ncurr.Next

        curr.Next = curr.Next.Next
        curr = curr.Next
    }

    <span style="color:#cdcd00">return</span> dummy.Next
}
</code></pre></div><h3 id="328-奇偶链表">328. 奇偶链表<a hidden class="anchor" aria-hidden="true" href="#328-奇偶链表">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">328. 奇偶链表</a>
给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。</p>
<p>第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。</p>
<p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。</p>
<p>你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for singly-linked list.
</span><span style="color:#000080"> * type ListNode struct {
</span><span style="color:#000080"> *     Val int
</span><span style="color:#000080"> *     Next *ListNode
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>
<span style="color:#00cd00">func</span> oddEvenList(head <span style="color:#39c">*</span>ListNode) <span style="color:#39c">*</span>ListNode {
    <span style="color:#cdcd00">if</span> head <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>
    }
    odd, even <span style="color:#39c">:=</span> head, head.Next
    eventHead <span style="color:#39c">:=</span> even

    <span style="color:#cdcd00">for</span> even <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> <span style="color:#39c">&amp;&amp;</span> even.Next <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        odd.Next = even.Next
        odd = odd.Next
        even.Next = odd.Next
        even = even.Next
    }

    odd.Next = eventHead
    <span style="color:#cdcd00">return</span> head
}
</code></pre></div><h3 id="83-删除排序链表中的重复元素">83. 删除排序链表中的重复元素<a hidden class="anchor" aria-hidden="true" href="#83-删除排序链表中的重复元素">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a>
给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for singly-linked list.
</span><span style="color:#000080"> * type ListNode struct {
</span><span style="color:#000080"> *     Val int
</span><span style="color:#000080"> *     Next *ListNode
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>
<span style="color:#00cd00">func</span> deleteDuplicates(head <span style="color:#39c">*</span>ListNode) <span style="color:#39c">*</span>ListNode {
    <span style="color:#cdcd00">if</span> head <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>
    }
    curr <span style="color:#39c">:=</span> head
    <span style="color:#cdcd00">for</span> curr.Next <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">if</span> curr.Val <span style="color:#39c">==</span> curr.Next.Val {
            curr.Next = curr.Next.Next
        } <span style="color:#cdcd00">else</span> {
            curr = curr.Next
        }
    }
    <span style="color:#cdcd00">return</span> head
}
</code></pre></div><h3 id="82-删除排序链表中的重复元素-ii">82. 删除排序链表中的重复元素 II<a hidden class="anchor" aria-hidden="true" href="#82-删除排序链表中的重复元素-ii">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a>
给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for singly-linked list.
</span><span style="color:#000080"> * type ListNode struct {
</span><span style="color:#000080"> *     Val int
</span><span style="color:#000080"> *     Next *ListNode
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>
<span style="color:#00cd00">func</span> deleteDuplicates(head <span style="color:#39c">*</span>ListNode) <span style="color:#39c">*</span>ListNode {
    dummy <span style="color:#39c">:=</span> <span style="color:#39c">&amp;</span>ListNode{Val: <span style="color:#39c">-</span><span style="color:#cd00cd">101</span>}
    dummy.Next = head
    curr <span style="color:#39c">:=</span> dummy

    <span style="color:#cdcd00">for</span> curr.Next <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> <span style="color:#39c">&amp;&amp;</span> curr.Next.Next <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">if</span> curr.Next.Val <span style="color:#39c">==</span> curr.Next.Next.Val {
            x <span style="color:#39c">:=</span> curr.Next.Val 
            <span style="color:#cdcd00">for</span> curr.Next <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> <span style="color:#39c">&amp;&amp;</span> curr.Next.Val <span style="color:#39c">==</span> x {
                curr.Next = curr.Next.Next
            }
        } <span style="color:#cdcd00">else</span> {
            curr = curr.Next
        }
    }

    <span style="color:#cdcd00">return</span> dummy.Next
}
</code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lambertxiao.github.io/tags/%E7%AE%97%E6%B3%95/">算法</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://lambertxiao.github.io/posts/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/doc/">
    <span class="title">« Prev Page</span>
    <br>
    <span>算法-滑动窗口</span>
  </a>
  <a class="next" href="https://lambertxiao.github.io/posts/golang/golang-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/doc/">
    <span class="title">Next Page »</span>
    <br>
    <span>golang-内存管理</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share 算法-链表 on twitter"
        href="https://twitter.com/intent/tweet/?text=%e7%ae%97%e6%b3%95-%e9%93%be%e8%a1%a8&amp;url=https%3a%2f%2flambertxiao.github.io%2fposts%2f%25E7%25AE%2597%25E6%25B3%2595%2f%25E7%25AE%2597%25E6%25B3%2595-%25E9%2593%25BE%25E8%25A1%25A8%2fdoc%2f&amp;hashtags=%e7%ae%97%e6%b3%95">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 算法-链表 on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flambertxiao.github.io%2fposts%2f%25E7%25AE%2597%25E6%25B3%2595%2f%25E7%25AE%2597%25E6%25B3%2595-%25E9%2593%25BE%25E8%25A1%25A8%2fdoc%2f&amp;title=%e7%ae%97%e6%b3%95-%e9%93%be%e8%a1%a8&amp;summary=%e7%ae%97%e6%b3%95-%e9%93%be%e8%a1%a8&amp;source=https%3a%2f%2flambertxiao.github.io%2fposts%2f%25E7%25AE%2597%25E6%25B3%2595%2f%25E7%25AE%2597%25E6%25B3%2595-%25E9%2593%25BE%25E8%25A1%25A8%2fdoc%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 算法-链表 on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2flambertxiao.github.io%2fposts%2f%25E7%25AE%2597%25E6%25B3%2595%2f%25E7%25AE%2597%25E6%25B3%2595-%25E9%2593%25BE%25E8%25A1%25A8%2fdoc%2f&title=%e7%ae%97%e6%b3%95-%e9%93%be%e8%a1%a8">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 算法-链表 on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flambertxiao.github.io%2fposts%2f%25E7%25AE%2597%25E6%25B3%2595%2f%25E7%25AE%2597%25E6%25B3%2595-%25E9%2593%25BE%25E8%25A1%25A8%2fdoc%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 算法-链表 on whatsapp"
        href="https://api.whatsapp.com/send?text=%e7%ae%97%e6%b3%95-%e9%93%be%e8%a1%a8%20-%20https%3a%2f%2flambertxiao.github.io%2fposts%2f%25E7%25AE%2597%25E6%25B3%2595%2f%25E7%25AE%2597%25E6%25B3%2595-%25E9%2593%25BE%25E8%25A1%25A8%2fdoc%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 算法-链表 on telegram"
        href="https://telegram.me/share/url?text=%e7%ae%97%e6%b3%95-%e9%93%be%e8%a1%a8&amp;url=https%3a%2f%2flambertxiao.github.io%2fposts%2f%25E7%25AE%2597%25E6%25B3%2595%2f%25E7%25AE%2597%25E6%25B3%2595-%25E9%2593%25BE%25E8%25A1%25A8%2fdoc%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer><div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "disqus_KY25sRiRtb" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://lambertxiao.github.io">Lambert&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
