<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>算法-二叉树 | Lambert&#39;s blog</title>
<meta name="keywords" content="算法, 二叉树" />
<meta name="description" content="子串和子序列是一块难啃的骨头，但大多数时候可以通过动态规划来解决">
<meta name="author" content="Lambert Xiao">
<link rel="canonical" href="https://lambertxiao.github.io/posts/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/doc/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.f930089bcedc85892fe03ed179c7aff545249b87bdabbcac09cc1895e74257eb.css" integrity="sha256-&#43;TAIm87chYkv4D7Recev9UUkm4e9q7ysCcwYledCV&#43;s=" rel="preload stylesheet" as="style">
<link rel="preload" href="/avatar.jpeg" as="image">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://lambertxiao.github.io/avatar.jpeg">
<link rel="icon" type="image/png" sizes="16x16" href="https://lambertxiao.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lambertxiao.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lambertxiao.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lambertxiao.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="算法-二叉树" />
<meta property="og:description" content="子串和子序列是一块难啃的骨头，但大多数时候可以通过动态规划来解决" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lambertxiao.github.io/posts/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/doc/" /><meta property="og:image" content="https://lambertxiao.github.io/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-13T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2022-03-13T00:00:00&#43;00:00" />
<meta property="og:see_also" content="https://lambertxiao.github.io/posts/gdb_usage/doc/" /><meta property="og:see_also" content="https://lambertxiao.github.io/posts/numa/doc/" /><meta property="og:see_also" content="https://lambertxiao.github.io/posts/uio/doc/" /><meta property="og:see_also" content="https://lambertxiao.github.io/posts/vfio/doc/" /><meta property="og:see_also" content="https://lambertxiao.github.io/posts/virtio/doc/" /><meta property="og:see_also" content="https://lambertxiao.github.io/posts/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/doc/" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://lambertxiao.github.io/papermod-cover.png"/>

<meta name="twitter:title" content="算法-二叉树"/>
<meta name="twitter:description" content="子串和子序列是一块难啃的骨头，但大多数时候可以通过动态规划来解决"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://lambertxiao.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "算法-二叉树",
      "item": "https://lambertxiao.github.io/posts/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/doc/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "算法-二叉树",
  "name": "算法-二叉树",
  "description": "子串和子序列是一块难啃的骨头，但大多数时候可以通过动态规划来解决",
  "keywords": [
    "算法", "二叉树"
  ],
  "articleBody": "617. 合并二叉树 617. 合并二叉树 给你两棵二叉树： root1 和 root2 。\n想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。\n返回合并后的二叉树。\n注意: 合并过程必须从两个树的根节点开始。\nfunc mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode { if root1 == nil { return root2 } if root2 == nil { return root1 } root := \u0026TreeNode{} root.Val = root1.Val + root2.Val root.Left = mergeTrees(root1.Left, root2.Left) root.Right = mergeTrees(root1.Right, root2.Right) return root } 543. 二叉树的直径 543. 二叉树的直径 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。\nfunc diameterOfBinaryTree(root *TreeNode) int { ans := 0 // fn定义为获取一个节点的深度  var depth func(root *TreeNode) int depth = func(root *TreeNode) int { if root == nil { return 0 } // 直径即为左深度加右深度  ld := depth(root.Left) rd := depth(root.Right) length := ld + rd if length  ans { ans = length } // 自己加上左右两边的长度  return max(ld, rd) + 1 } depth(root) return ans } 538. 把二叉搜索树转换为累加树 538. 把二叉搜索树转换为累加树 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。\n提醒一下，二叉搜索树满足下列约束条件：\n节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。\nfunc convertBST(root *TreeNode) *TreeNode { preVal := 0 var traverse func(root *TreeNode) traverse = func(root *TreeNode) { if root == nil { return } traverse(root.Right) root.Val = root.Val + preVal preVal = root.Val traverse(root.Left) } traverse(root) return root } 437. 路径总和 III 437. 路径总和 III 给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。\n路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。\nfunc pathSum(root *TreeNode, targetSum int) int { cnt := 0 preSum := map[int]int{0: 1} // 从root点出发，能找到和为target的path的数量  var dfs func(root *TreeNode, curr int) dfs = func(root *TreeNode, curr int) { if root == nil { return } curr += root.Val cnt += preSum[curr - targetSum] preSum[curr]++ dfs(root.Left, curr) dfs(root.Right, curr) // 当左边和右边都处理完后，回溯当前的节点产生的和  preSum[curr]-- } dfs(root, 0) return cnt } 235. 二叉搜索树的最近公共祖先 235. 二叉搜索树的最近公共祖先\n给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == p || root == q { return root } // 在左边找  if p.Val \u0026\u0026 q.Val return lowestCommonAncestor(root.Left, p, q) } // 在右边找  if p.Val  root.Val \u0026\u0026 q.Val  root.Val { return lowestCommonAncestor(root.Right, p, q) } // 一大一小的公共祖先一定是root  return root } 236. 二叉树的最近公共祖先 236. 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == p || root == q { return root } // 在左边找  left := lowestCommonAncestor(root.Left, p, q) // 在右边找  right := lowestCommonAncestor(root.Right, p, q) // 情况1： p, q不存在  if left == nil \u0026\u0026 right == nil { return nil } // 情况2: p，q各自存在与左右子树中  if left != nil \u0026\u0026 right != nil { return root } // 情况3: p，qt同在一边  if left == nil { return right } else { return left } } 226. 翻转二叉树 226. 翻转二叉树 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。\nfunc invertTree(root *TreeNode) *TreeNode { if root == nil { return nil } root.Left, root.Right = root.Right, root.Left invertTree(root.Left) invertTree(root.Right) return root } 124. 二叉树中的最大路径和 124. 二叉树中的最大路径和 路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。\n路径和 是路径中各节点值的总和。\n给你一个二叉树的根节点 root ，返回其 最大路径和 。\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxPathSum(root *TreeNode) int { maxPath := -1001 var maxGain func(root *TreeNode) int maxGain = func(root *TreeNode) int { if root == nil { return 0 } leftGain := max(maxGain(root.Left), 0) rightGain := max(maxGain(root.Right), 0) // 当前节点+左边路径+右边路径即为一个path  maxPath = max(maxPath, root.Val + leftGain + rightGain) return root.Val + max(leftGain, rightGain) } maxGain(root) return maxPath } func max(x, y int) int { if x  y { return x } return y } 114. 二叉树展开为链表 114. 二叉树展开为链表 给你二叉树的根结点 root ，请你将它展开为一个单链表：\n展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func flatten(root *TreeNode) { curr := root for curr != nil { if curr.Left != nil { left := curr.Left // 在左子树中寻找最右边的节点，这个节点会是curr右子树的前驱节点  rLeft := left for rLeft.Right != nil { rLeft = rLeft.Right } rLeft.Right = curr.Right curr.Right = left curr.Left = nil } curr = curr.Right } } 105. 从前序与中序遍历序列构造二叉树 105. 从前序与中序遍历序列构造二叉树 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(preorder []int, inorder []int) *TreeNode { if len(inorder) == 0 { return nil } rootVal := preorder[0] idx := 0 // 左右子树分节点  for i, val := range inorder { if val == rootVal { idx = i break } } root := \u0026TreeNode{Val: rootVal} root.Left = buildTree(preorder[1:idx+1], inorder[:idx]) root.Right = buildTree(preorder[idx+1:], inorder[idx+1:]) return root } 106. 从中序与后序遍历序列构造二叉树 106. 从中序与后序遍历序列构造二叉树 给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(inorder []int, postorder []int) *TreeNode { if len(inorder) == 0 { return nil } rootVal := postorder[len(postorder)-1] idx := 0 // 左右子树分节点  for i, val := range inorder { if val == rootVal { idx = i break } } root := \u0026TreeNode{Val: rootVal} root.Left = buildTree(inorder[:idx], postorder[:idx]) root.Right = buildTree(inorder[idx+1:], postorder[idx:len(postorder)-1]) return root } 104. 二叉树的最大深度 104. 二叉树的最大深度 给定一个二叉树，找出其最大深度。\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n说明: 叶子节点是指没有子节点的节点。\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxDepth(root *TreeNode) int { if root == nil { return 0 } return max(maxDepth(root.Left), maxDepth(root.Right)) + 1 } func max(x, y int) int { if x  y { return x } return y } 102. 二叉树的层序遍历 102. 二叉树的层序遍历 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrder(root *TreeNode) [][]int { ans := [][]int{} if root == nil { return ans } q := []*TreeNode{root} for len(q) != 0 { level := []int{} size := len(q) for i := 0; i ++ { level = append(level, q[i].Val) if q[i].Left != nil { q = append(q, q[i].Left) } if q[i].Right != nil { q = append(q, q[i].Right) } } ans = append(ans, level) q = q[size:] } return ans } 101. 对称二叉树 101. 对称二叉树 给你一个二叉树的根节点 root ， 检查它是否轴对称。\nfunc isSymmetric(root *TreeNode) bool { return check(root, root) } func check(left *TreeNode, right *TreeNode) bool { if left == nil \u0026\u0026 right == nil { return true } if left == nil || right == nil { return false } if left.Val != right.Val { return false } return check(left.Left, right.Right) \u0026\u0026 check(left.Right, right.Left) } 98. 验证二叉搜索树 98. 验证二叉搜索树 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。\n有效 二叉搜索树定义如下：\n节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。\nfunc isValidBST(root *TreeNode) bool { return f(root, math.MinInt64, math.MaxInt64) } func f(root *TreeNode, min int64, max int64) bool { if root == nil { return true } if int64(root.Val)  min || int64(root.Val) = max { return false } return f(root.Left, min, int64(root.Val)) \u0026\u0026 f(root.Right, int64(root.Val), max) } 96. 不同的二叉搜索树 96. 不同的二叉搜索树 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。\nclass Solution { public int numTrees(int n) { // 状态 节点数  // 选择 选择哪个节点作为根节点  // 状态转移方程  // dp(n) 使用n个节点，能组成的二叉搜索树种数  // f(i, n) 使用i节点为根，能组成长度为n的二叉搜索树种数  // dp(n) = sum(f(i, n)), i属于1到n  // f(i, n) = dp(i - 1) * dp(n - i)  // dp(n) = sum(dp(i - 1) * dp(n - i)), i属于1到n  // baseCase  // dp[0] = 0  // dp[1] = 1  // dp[2] = 2  // dp[3] = 5  int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i  n; i++) { for (int j = 1; j  i; j++) { dp[i] += dp[j - 1] * dp[i - j]; } } return dp[n]; } } 94. 二叉树的中序遍历 94. 二叉树的中序遍历 给定一个二叉树的根节点 root ，返回它的 中序 遍历。\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 递归 func inorderTraversal(root *TreeNode) []int { ans := []int{} var r func(root *TreeNode) r = func(root *TreeNode) { if root == nil { return } r(root.Left) ans = append(ans, root.Val) r(root.Right) } r(root) return ans } // 迭代 func inorderTraversal2(root *TreeNode) []int { if root == nil { return []int{} } // 核心思想要用栈模拟  stack := []*TreeNode{} ans := []int{} curr := root // 用来指向当前操作的节点  for curr != nil || len(stack) != 0 { if curr != nil { stack = append(stack, curr) curr = curr.Left } else { n := len(stack) - 1 curr = stack[n] stack = stack[:n] ans = append(ans, curr.Val) curr = curr.Right } } return ans } 110. 平衡二叉树 110. 平衡二叉树 给定一个二叉树，判断它是否是高度平衡的二叉树。\n本题中，一棵高度平衡二叉树定义为：\n一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isBalanced(root *TreeNode) bool { h := height(root) return h != -1 } func height(root *TreeNode) int { if root == nil { return 0 } leftH := height(root.Left) rightH := height(root.Right) if leftH == -1 || rightH == -1 || abs(leftH - rightH)  1 { return -1 // -1代表不平衡，不需要再继续了  } return max(leftH, rightH) + 1 } 129. 求根节点到叶节点数字之和 129. 求根节点到叶节点数字之和 给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。 每条从根节点到叶节点的路径都代表一个数字：\n例如，从根节点到叶节点的路径 1 - 2 - 3 表示数字 123 。 计算从根节点到叶节点生成的 所有数字之和 。\n叶节点 是指没有子节点的节点。\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func sumNumbers(root *TreeNode) int { if root == nil { return 0 } var dfs func(root *TreeNode, sum int) int dfs = func(root *TreeNode, sum int) int { if root == nil { return 0 } rootSum := root.Val + sum * 10 if root.Left == nil \u0026\u0026 root.Right == nil { return rootSum } leftSum := dfs(root.Left, rootSum) rightSum := dfs(root.Right, rootSum) return leftSum + rightSum } return dfs(root, 0) } 109. 有序链表转换二叉搜索树 109. 有序链表转换二叉搜索树\n思路：\n 找到链表的中点，一分为二 中点为head，并且递归生成左右子树 当 left == right 时，证明已经构建完成（可以这么理解，left和right是左闭右开，当left==right时，证明left已经超过边界了）  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func sortedListToBST(head *ListNode) *TreeNode { return build(head, nil) } func build(left *ListNode, right *ListNode) *TreeNode { if left == right { return nil } mid := findMid(left, right) head := \u0026TreeNode{Val: mid.Val} head.Left = build(left, mid) head.Right = build(mid.Next, right) return head } func findMid(left, right *ListNode) *ListNode { s, f := left, left for f != right \u0026\u0026 f.Next != right { s = s.Next f = f.Next.Next } return s } 450. 删除二叉搜索树中的节点 450. 删除二叉搜索树中的节点\n给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n一般来说，删除节点可分为两个步骤：\n首先找到需要删除的节点； 如果找到了，删除它。\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func deleteNode(root *TreeNode, key int) *TreeNode { if root == nil { return nil } if root.Val == key { // 叶子节点，直接删除  if root.Left == nil \u0026\u0026 root.Right == nil { // 当前节点被删，返回空  return nil } // 左子树为空，右子树上来继位  if root.Left == nil { return root.Right } // 右子树为空，左子树上来继位  if root.Right == nil { return root.Left } // 左右都不为空，将左子树的头节点接到右子树里最左节点的左节点上  leftRoot := root.Left leftestNode := root.Right // 右子树里最左边的节点  for leftestNode.Left != nil { leftestNode = leftestNode.Left } leftestNode.Left = leftRoot return root.Right } if root.Val else { root.Left = deleteNode(root.Left, key) } return root } 297. 二叉树的序列化与反序列化 297. 二叉树的序列化与反序列化\n序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。\n请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ type Codec struct {} func Constructor() Codec { c := Codec{} return c } // Serializes a tree to a single string. func (c *Codec) serialize(root *TreeNode) string { ans := []string{} q := []*TreeNode {root} for len(q) != 0 { node := q[0] q = q[1:] if node != nil { ans = append(ans, strconv.Itoa(node.Val)) q = append(q, node.Left) q = append(q, node.Right) } else { ans = append(ans, \"X\") } } return strings.Join(ans, \",\") } // Deserializes your encoded data to tree. func (c *Codec) deserialize(data string) *TreeNode { if data == \"X\" { return nil } nodes := strings.Split(data, \",\") v, _ := strconv.Atoi(nodes[0]) root := \u0026TreeNode{Val: v} q := []*TreeNode {root} curr := 1 for curr len(nodes) { node := q[0] q = q[1:] leftVal := nodes[curr] if leftVal != \"X\" { _leftVal, _ := strconv.Atoi(leftVal) leftNode := \u0026TreeNode{Val: _leftVal} node.Left = leftNode q = append(q, leftNode) } rightVal := nodes[curr+1] if rightVal != \"X\" { _rightVal, _ := strconv.Atoi(rightVal) rightNode := \u0026TreeNode{Val: _rightVal} node.Right = rightNode q = append(q, rightNode) } curr += 2 } return root } /** * Your Codec object will be instantiated and called as such: * ser := Constructor(); * deser := Constructor(); * data := ser.serialize(root); * ans := deser.deserialize(data); */ 700. 二叉搜索树中的搜索 700. 二叉搜索树中的搜索\n给定二叉搜索树（BST）的根节点 root 和一个整数值 val。\n你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。\n/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func searchBST(root *TreeNode, val int) *TreeNode { if root == nil || root.Val == val { return root } if val  root.Val { return searchBST(root.Left, val) } return searchBST(root.Right, val) } ",
  "wordCount" : "2275",
  "inLanguage": "en",
  "datePublished": "2022-03-13T00:00:00Z",
  "dateModified": "2022-03-13T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Lambert Xiao"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lambertxiao.github.io/posts/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/doc/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Lambert's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lambertxiao.github.io/avatar.jpeg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lambertxiao.github.io" accesskey="h" title="Lambert&#39;s Blog (Alt + H)">
                <img src="https://lambertxiao.github.io/avatar.jpeg" alt="logo" aria-label="logo"
                    height="35">Lambert&#39;s Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lambertxiao.github.io/archives" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="https://lambertxiao.github.io/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="https://lambertxiao.github.io/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://lambertxiao.github.io">Home</a>&nbsp;»&nbsp;<a href="https://lambertxiao.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      算法-二叉树
    </h1>
    <div class="post-meta"><span title='2022-03-13 00:00:00 +0000 UTC'>March 13, 2022</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Lambert Xiao&nbsp;|&nbsp;<a href="https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content/posts/%e7%ae%97%e6%b3%95/%e7%ae%97%e6%b3%95-%e4%ba%8c%e5%8f%89%e6%a0%91/doc.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#617-%e5%90%88%e5%b9%b6%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="617. 合并二叉树">617. 合并二叉树</a></li>
                <li>
                    <a href="#543-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e7%9b%b4%e5%be%84" aria-label="543. 二叉树的直径">543. 二叉树的直径</a></li>
                <li>
                    <a href="#538-%e6%8a%8a%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e8%bd%ac%e6%8d%a2%e4%b8%ba%e7%b4%af%e5%8a%a0%e6%a0%91" aria-label="538. 把二叉搜索树转换为累加树">538. 把二叉搜索树转换为累加树</a></li>
                <li>
                    <a href="#437-%e8%b7%af%e5%be%84%e6%80%bb%e5%92%8c-iii" aria-label="437. 路径总和 III">437. 路径总和 III</a></li>
                <li>
                    <a href="#235-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88" aria-label="235. 二叉搜索树的最近公共祖先">235. 二叉搜索树的最近公共祖先</a></li>
                <li>
                    <a href="#236-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88" aria-label="236. 二叉树的最近公共祖先">236. 二叉树的最近公共祖先</a></li>
                <li>
                    <a href="#226-%e7%bf%bb%e8%bd%ac%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="226. 翻转二叉树">226. 翻转二叉树</a></li>
                <li>
                    <a href="#124-%e4%ba%8c%e5%8f%89%e6%a0%91%e4%b8%ad%e7%9a%84%e6%9c%80%e5%a4%a7%e8%b7%af%e5%be%84%e5%92%8c" aria-label="124. 二叉树中的最大路径和">124. 二叉树中的最大路径和</a></li>
                <li>
                    <a href="#114-%e4%ba%8c%e5%8f%89%e6%a0%91%e5%b1%95%e5%bc%80%e4%b8%ba%e9%93%be%e8%a1%a8" aria-label="114. 二叉树展开为链表">114. 二叉树展开为链表</a></li>
                <li>
                    <a href="#105-%e4%bb%8e%e5%89%8d%e5%ba%8f%e4%b8%8e%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="105. 从前序与中序遍历序列构造二叉树">105. 从前序与中序遍历序列构造二叉树</a></li>
                <li>
                    <a href="#106-%e4%bb%8e%e4%b8%ad%e5%ba%8f%e4%b8%8e%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86%e5%ba%8f%e5%88%97%e6%9e%84%e9%80%a0%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="106. 从中序与后序遍历序列构造二叉树">106. 从中序与后序遍历序列构造二叉树</a></li>
                <li>
                    <a href="#104-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e6%9c%80%e5%a4%a7%e6%b7%b1%e5%ba%a6" aria-label="104. 二叉树的最大深度">104. 二叉树的最大深度</a></li>
                <li>
                    <a href="#102-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%b1%82%e5%ba%8f%e9%81%8d%e5%8e%86" aria-label="102. 二叉树的层序遍历">102. 二叉树的层序遍历</a></li>
                <li>
                    <a href="#101-%e5%af%b9%e7%a7%b0%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="101. 对称二叉树">101. 对称二叉树</a></li>
                <li>
                    <a href="#98-%e9%aa%8c%e8%af%81%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91" aria-label="98. 验证二叉搜索树">98. 验证二叉搜索树</a></li>
                <li>
                    <a href="#96-%e4%b8%8d%e5%90%8c%e7%9a%84%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91" aria-label="96. 不同的二叉搜索树">96. 不同的二叉搜索树</a></li>
                <li>
                    <a href="#94-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e4%b8%ad%e5%ba%8f%e9%81%8d%e5%8e%86" aria-label="94. 二叉树的中序遍历">94. 二叉树的中序遍历</a></li>
                <li>
                    <a href="#110-%e5%b9%b3%e8%a1%a1%e4%ba%8c%e5%8f%89%e6%a0%91" aria-label="110. 平衡二叉树">110. 平衡二叉树</a></li>
                <li>
                    <a href="#129-%e6%b1%82%e6%a0%b9%e8%8a%82%e7%82%b9%e5%88%b0%e5%8f%b6%e8%8a%82%e7%82%b9%e6%95%b0%e5%ad%97%e4%b9%8b%e5%92%8c" aria-label="129. 求根节点到叶节点数字之和">129. 求根节点到叶节点数字之和</a></li>
                <li>
                    <a href="#109-%e6%9c%89%e5%ba%8f%e9%93%be%e8%a1%a8%e8%bd%ac%e6%8d%a2%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91" aria-label="109. 有序链表转换二叉搜索树">109. 有序链表转换二叉搜索树</a></li>
                <li>
                    <a href="#450-%e5%88%a0%e9%99%a4%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e8%8a%82%e7%82%b9" aria-label="450. 删除二叉搜索树中的节点">450. 删除二叉搜索树中的节点</a></li>
                <li>
                    <a href="#297-%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%e4%b8%8e%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96" aria-label="297. 二叉树的序列化与反序列化">297. 二叉树的序列化与反序列化</a></li>
                <li>
                    <a href="#700-%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e4%b8%ad%e7%9a%84%e6%90%9c%e7%b4%a2" aria-label="700. 二叉搜索树中的搜索">700. 二叉搜索树中的搜索</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="617-合并二叉树">617. 合并二叉树<a hidden class="anchor" aria-hidden="true" href="#617-合并二叉树">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a>
给你两棵二叉树： root1 和 root2 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p>注意: 合并过程必须从两个树的根节点开始。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00cd00">func</span> mergeTrees(root1 <span style="color:#39c">*</span>TreeNode, root2 <span style="color:#39c">*</span>TreeNode) <span style="color:#39c">*</span>TreeNode {
    <span style="color:#cdcd00">if</span> root1 <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> root2
    }
    <span style="color:#cdcd00">if</span> root2 <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> root1
    }

    root <span style="color:#39c">:=</span> <span style="color:#39c">&amp;</span>TreeNode{}
    root.Val = root1.Val <span style="color:#39c">+</span> root2.Val
    root.Left = mergeTrees(root1.Left, root2.Left)
    root.Right = mergeTrees(root1.Right, root2.Right)

    <span style="color:#cdcd00">return</span> root
}
</code></pre></div><h3 id="543-二叉树的直径">543. 二叉树的直径<a hidden class="anchor" aria-hidden="true" href="#543-二叉树的直径">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a>
给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00cd00">func</span> diameterOfBinaryTree(root <span style="color:#39c">*</span>TreeNode) <span style="color:#00cd00">int</span> {
    ans <span style="color:#39c">:=</span> <span style="color:#cd00cd">0</span>

    <span style="color:#000080">// fn定义为获取一个节点的深度
</span><span style="color:#000080"></span>    <span style="color:#00cd00">var</span> depth <span style="color:#00cd00">func</span>(root <span style="color:#39c">*</span>TreeNode) <span style="color:#00cd00">int</span>
    depth = <span style="color:#00cd00">func</span>(root <span style="color:#39c">*</span>TreeNode) <span style="color:#00cd00">int</span> {
        <span style="color:#cdcd00">if</span> root <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> { <span style="color:#cdcd00">return</span> <span style="color:#cd00cd">0</span> }

        <span style="color:#000080">// 直径即为左深度加右深度
</span><span style="color:#000080"></span>        ld <span style="color:#39c">:=</span> depth(root.Left)
        rd <span style="color:#39c">:=</span> depth(root.Right)
        length <span style="color:#39c">:=</span> ld <span style="color:#39c">+</span> rd
        <span style="color:#cdcd00">if</span> length &gt; ans {
            ans = length
        }

        <span style="color:#000080">// 自己加上左右两边的长度
</span><span style="color:#000080"></span>        <span style="color:#cdcd00">return</span> max(ld, rd) <span style="color:#39c">+</span> <span style="color:#cd00cd">1</span>
    }

    depth(root)
    <span style="color:#cdcd00">return</span> ans
}
</code></pre></div><h3 id="538-把二叉搜索树转换为累加树">538. 把二叉搜索树转换为累加树<a hidden class="anchor" aria-hidden="true" href="#538-把二叉搜索树转换为累加树">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a>
给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<p>节点的左子树仅包含键 小于 节点键的节点。
节点的右子树仅包含键 大于 节点键的节点。
左右子树也必须是二叉搜索树。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00cd00">func</span> convertBST(root <span style="color:#39c">*</span>TreeNode) <span style="color:#39c">*</span>TreeNode {
    preVal <span style="color:#39c">:=</span> <span style="color:#cd00cd">0</span>
    <span style="color:#00cd00">var</span> traverse <span style="color:#00cd00">func</span>(root <span style="color:#39c">*</span>TreeNode)
    traverse = <span style="color:#00cd00">func</span>(root <span style="color:#39c">*</span>TreeNode) {
        <span style="color:#cdcd00">if</span> root <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
            <span style="color:#cdcd00">return</span>
        }

        traverse(root.Right)
        root.Val = root.Val <span style="color:#39c">+</span> preVal
        preVal = root.Val
        traverse(root.Left)
    }

    traverse(root)
    <span style="color:#cdcd00">return</span> root
}
</code></pre></div><h3 id="437-路径总和-iii">437. 路径总和 III<a hidden class="anchor" aria-hidden="true" href="#437-路径总和-iii">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a>
给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p>
<p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00cd00">func</span> pathSum(root <span style="color:#39c">*</span>TreeNode, targetSum <span style="color:#00cd00">int</span>) <span style="color:#00cd00">int</span> {
    cnt <span style="color:#39c">:=</span> <span style="color:#cd00cd">0</span>
    preSum <span style="color:#39c">:=</span> <span style="color:#00cd00">map</span>[<span style="color:#00cd00">int</span>]<span style="color:#00cd00">int</span>{<span style="color:#cd00cd">0</span>: <span style="color:#cd00cd">1</span>}
    <span style="color:#000080">// 从root点出发，能找到和为target的path的数量
</span><span style="color:#000080"></span>    <span style="color:#00cd00">var</span> dfs <span style="color:#00cd00">func</span>(root <span style="color:#39c">*</span>TreeNode, curr <span style="color:#00cd00">int</span>)
    dfs = <span style="color:#00cd00">func</span>(root <span style="color:#39c">*</span>TreeNode, curr <span style="color:#00cd00">int</span>) {
        <span style="color:#cdcd00">if</span> root <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
            <span style="color:#cdcd00">return</span>
        }

        curr <span style="color:#39c">+=</span> root.Val
        cnt <span style="color:#39c">+=</span> preSum[curr <span style="color:#39c">-</span> targetSum]
        preSum[curr]<span style="color:#39c">++</span>
        
        dfs(root.Left, curr)
        dfs(root.Right, curr)
        <span style="color:#000080">// 当左边和右边都处理完后，回溯当前的节点产生的和
</span><span style="color:#000080"></span>        preSum[curr]<span style="color:#39c">--</span>
    }
    
    dfs(root, <span style="color:#cd00cd">0</span>)
    <span style="color:#cdcd00">return</span> cnt
}
</code></pre></div><h3 id="235-二叉搜索树的最近公共祖先">235. 二叉搜索树的最近公共祖先<a hidden class="anchor" aria-hidden="true" href="#235-二叉搜索树的最近公共祖先">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></p>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for a binary tree node.
</span><span style="color:#000080"> * type TreeNode struct {
</span><span style="color:#000080"> *     Val   int
</span><span style="color:#000080"> *     Left  *TreeNode
</span><span style="color:#000080"> *     Right *TreeNode
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>

<span style="color:#00cd00">func</span> lowestCommonAncestor(root, p, q <span style="color:#39c">*</span>TreeNode) <span style="color:#39c">*</span>TreeNode {
	<span style="color:#cdcd00">if</span> root <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>
    }

    <span style="color:#cdcd00">if</span> root <span style="color:#39c">==</span> p <span style="color:#39c">||</span> root <span style="color:#39c">==</span> q {
        <span style="color:#cdcd00">return</span> root
    }

    <span style="color:#000080">// 在左边找
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">if</span> p.Val &lt; root.Val <span style="color:#39c">&amp;&amp;</span> q.Val &lt; root.Val {
        <span style="color:#cdcd00">return</span> lowestCommonAncestor(root.Left, p, q)
    }
    <span style="color:#000080">// 在右边找
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">if</span> p.Val &gt; root.Val <span style="color:#39c">&amp;&amp;</span> q.Val &gt; root.Val {
        <span style="color:#cdcd00">return</span> lowestCommonAncestor(root.Right, p, q)
    }

    <span style="color:#000080">// 一大一小的公共祖先一定是root
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">return</span> root
}
</code></pre></div><h3 id="236-二叉树的最近公共祖先">236. 二叉树的最近公共祖先<a hidden class="anchor" aria-hidden="true" href="#236-二叉树的最近公共祖先">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a>
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00cd00">func</span> lowestCommonAncestor(root, p, q <span style="color:#39c">*</span>TreeNode) <span style="color:#39c">*</span>TreeNode {
    <span style="color:#cdcd00">if</span> root <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>
    }

    <span style="color:#cdcd00">if</span> root <span style="color:#39c">==</span> p <span style="color:#39c">||</span> root <span style="color:#39c">==</span> q {
        <span style="color:#cdcd00">return</span> root
    }

    <span style="color:#000080">// 在左边找
</span><span style="color:#000080"></span>    left <span style="color:#39c">:=</span> lowestCommonAncestor(root.Left, p, q)
    <span style="color:#000080">// 在右边找
</span><span style="color:#000080"></span>    right <span style="color:#39c">:=</span> lowestCommonAncestor(root.Right, p, q)

    <span style="color:#000080">// 情况1： p, q不存在
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">if</span> left <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> <span style="color:#39c">&amp;&amp;</span> right <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>
    }

    <span style="color:#000080">// 情况2: p，q各自存在与左右子树中
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">if</span> left <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> <span style="color:#39c">&amp;&amp;</span> right <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> root
    }

    <span style="color:#000080">// 情况3: p，qt同在一边
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">if</span> left <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> right
    } <span style="color:#cdcd00">else</span> {
        <span style="color:#cdcd00">return</span> left
    }
}
</code></pre></div><h3 id="226-翻转二叉树">226. 翻转二叉树<a hidden class="anchor" aria-hidden="true" href="#226-翻转二叉树">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a>
给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00cd00">func</span> invertTree(root <span style="color:#39c">*</span>TreeNode) <span style="color:#39c">*</span>TreeNode {
    <span style="color:#cdcd00">if</span> root <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> { <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span> }
    root.Left, root.Right = root.Right, root.Left
    invertTree(root.Left)
    invertTree(root.Right)
    <span style="color:#cdcd00">return</span> root
}
</code></pre></div><h3 id="124-二叉树中的最大路径和">124. 二叉树中的最大路径和<a hidden class="anchor" aria-hidden="true" href="#124-二叉树中的最大路径和">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a>
路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for a binary tree node.
</span><span style="color:#000080"> * type TreeNode struct {
</span><span style="color:#000080"> *     Val int
</span><span style="color:#000080"> *     Left *TreeNode
</span><span style="color:#000080"> *     Right *TreeNode
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>
<span style="color:#00cd00">func</span> maxPathSum(root <span style="color:#39c">*</span>TreeNode) <span style="color:#00cd00">int</span> {
    maxPath <span style="color:#39c">:=</span> <span style="color:#39c">-</span><span style="color:#cd00cd">1001</span>
    <span style="color:#00cd00">var</span> maxGain <span style="color:#00cd00">func</span>(root <span style="color:#39c">*</span>TreeNode) <span style="color:#00cd00">int</span>
    maxGain = <span style="color:#00cd00">func</span>(root <span style="color:#39c">*</span>TreeNode) <span style="color:#00cd00">int</span> {
        <span style="color:#cdcd00">if</span> root <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
            <span style="color:#cdcd00">return</span> <span style="color:#cd00cd">0</span>
        }
        leftGain <span style="color:#39c">:=</span> max(maxGain(root.Left), <span style="color:#cd00cd">0</span>)
        rightGain <span style="color:#39c">:=</span> max(maxGain(root.Right), <span style="color:#cd00cd">0</span>)
        <span style="color:#000080">// 当前节点+左边路径+右边路径即为一个path
</span><span style="color:#000080"></span>        maxPath = max(maxPath, root.Val <span style="color:#39c">+</span> leftGain <span style="color:#39c">+</span> rightGain)

        <span style="color:#cdcd00">return</span> root.Val <span style="color:#39c">+</span> max(leftGain, rightGain)
    }
    maxGain(root)
    <span style="color:#cdcd00">return</span> maxPath
}

<span style="color:#00cd00">func</span> max(x, y <span style="color:#00cd00">int</span>) <span style="color:#00cd00">int</span> {
    <span style="color:#cdcd00">if</span> x &gt; y { <span style="color:#cdcd00">return</span> x }
    <span style="color:#cdcd00">return</span> y
}
</code></pre></div><h3 id="114-二叉树展开为链表">114. 二叉树展开为链表<a hidden class="anchor" aria-hidden="true" href="#114-二叉树展开为链表">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a>
给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin">先序遍历</a> 顺序相同。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for a binary tree node.
</span><span style="color:#000080"> * type TreeNode struct {
</span><span style="color:#000080"> *     Val int
</span><span style="color:#000080"> *     Left *TreeNode
</span><span style="color:#000080"> *     Right *TreeNode
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>
<span style="color:#00cd00">func</span> flatten(root <span style="color:#39c">*</span>TreeNode)  {
    curr <span style="color:#39c">:=</span> root
    <span style="color:#cdcd00">for</span> curr <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">if</span> curr.Left <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
            left <span style="color:#39c">:=</span> curr.Left
            <span style="color:#000080">// 在左子树中寻找最右边的节点，这个节点会是curr右子树的前驱节点
</span><span style="color:#000080"></span>            rLeft <span style="color:#39c">:=</span> left
            <span style="color:#cdcd00">for</span> rLeft.Right <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
                rLeft = rLeft.Right
            }
            rLeft.Right = curr.Right
            curr.Right = left
            curr.Left = <span style="color:#cdcd00">nil</span>
        }
        curr = curr.Right
    }
}
</code></pre></div><h3 id="105-从前序与中序遍历序列构造二叉树">105. 从前序与中序遍历序列构造二叉树<a hidden class="anchor" aria-hidden="true" href="#105-从前序与中序遍历序列构造二叉树">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a>
给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for a binary tree node.
</span><span style="color:#000080"> * type TreeNode struct {
</span><span style="color:#000080"> *     Val int
</span><span style="color:#000080"> *     Left *TreeNode
</span><span style="color:#000080"> *     Right *TreeNode
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>
<span style="color:#00cd00">func</span> buildTree(preorder []<span style="color:#00cd00">int</span>, inorder []<span style="color:#00cd00">int</span>) <span style="color:#39c">*</span>TreeNode {
    <span style="color:#cdcd00">if</span> <span style="color:#cd00cd">len</span>(inorder) <span style="color:#39c">==</span> <span style="color:#cd00cd">0</span> {
        <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>
    }

    rootVal <span style="color:#39c">:=</span> preorder[<span style="color:#cd00cd">0</span>]
    idx <span style="color:#39c">:=</span> <span style="color:#cd00cd">0</span> <span style="color:#000080">// 左右子树分节点
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">for</span> i, val <span style="color:#39c">:=</span> <span style="color:#cdcd00">range</span> inorder {
        <span style="color:#cdcd00">if</span> val <span style="color:#39c">==</span> rootVal {
            idx = i
            <span style="color:#cdcd00">break</span>
        }
    }

    root <span style="color:#39c">:=</span> <span style="color:#39c">&amp;</span>TreeNode{Val: rootVal}
    root.Left = buildTree(preorder[<span style="color:#cd00cd">1</span>:idx<span style="color:#39c">+</span><span style="color:#cd00cd">1</span>], inorder[:idx])
    root.Right = buildTree(preorder[idx<span style="color:#39c">+</span><span style="color:#cd00cd">1</span>:], inorder[idx<span style="color:#39c">+</span><span style="color:#cd00cd">1</span>:])
    <span style="color:#cdcd00">return</span> root
}
</code></pre></div><h3 id="106-从中序与后序遍历序列构造二叉树">106. 从中序与后序遍历序列构造二叉树<a hidden class="anchor" aria-hidden="true" href="#106-从中序与后序遍历序列构造二叉树">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a>
给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for a binary tree node.
</span><span style="color:#000080"> * type TreeNode struct {
</span><span style="color:#000080"> *     Val int
</span><span style="color:#000080"> *     Left *TreeNode
</span><span style="color:#000080"> *     Right *TreeNode
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>
<span style="color:#00cd00">func</span> buildTree(inorder []<span style="color:#00cd00">int</span>, postorder []<span style="color:#00cd00">int</span>) <span style="color:#39c">*</span>TreeNode {
    <span style="color:#cdcd00">if</span> <span style="color:#cd00cd">len</span>(inorder) <span style="color:#39c">==</span> <span style="color:#cd00cd">0</span> {
        <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>
    }

    rootVal <span style="color:#39c">:=</span> postorder[<span style="color:#cd00cd">len</span>(postorder)<span style="color:#39c">-</span><span style="color:#cd00cd">1</span>]
    idx <span style="color:#39c">:=</span> <span style="color:#cd00cd">0</span> <span style="color:#000080">// 左右子树分节点
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">for</span> i, val <span style="color:#39c">:=</span> <span style="color:#cdcd00">range</span> inorder {
        <span style="color:#cdcd00">if</span> val <span style="color:#39c">==</span> rootVal {
            idx = i
            <span style="color:#cdcd00">break</span>
        }
    }

    root <span style="color:#39c">:=</span> <span style="color:#39c">&amp;</span>TreeNode{Val: rootVal}
    root.Left = buildTree(inorder[:idx], postorder[:idx])
    root.Right = buildTree(inorder[idx<span style="color:#39c">+</span><span style="color:#cd00cd">1</span>:], postorder[idx:<span style="color:#cd00cd">len</span>(postorder)<span style="color:#39c">-</span><span style="color:#cd00cd">1</span>])
    <span style="color:#cdcd00">return</span> root
}
</code></pre></div><h3 id="104-二叉树的最大深度">104. 二叉树的最大深度<a hidden class="anchor" aria-hidden="true" href="#104-二叉树的最大深度">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a>
给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for a binary tree node.
</span><span style="color:#000080"> * type TreeNode struct {
</span><span style="color:#000080"> *     Val int
</span><span style="color:#000080"> *     Left *TreeNode
</span><span style="color:#000080"> *     Right *TreeNode
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>
<span style="color:#00cd00">func</span> maxDepth(root <span style="color:#39c">*</span>TreeNode) <span style="color:#00cd00">int</span> {
    <span style="color:#cdcd00">if</span> root <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> <span style="color:#cd00cd">0</span>
    }

    <span style="color:#cdcd00">return</span> max(maxDepth(root.Left), maxDepth(root.Right)) <span style="color:#39c">+</span> <span style="color:#cd00cd">1</span>
}

<span style="color:#00cd00">func</span> max(x, y <span style="color:#00cd00">int</span>) <span style="color:#00cd00">int</span> {
    <span style="color:#cdcd00">if</span> x &gt; y { <span style="color:#cdcd00">return</span> x }
    <span style="color:#cdcd00">return</span> y
}
</code></pre></div><h3 id="102-二叉树的层序遍历">102. 二叉树的层序遍历<a hidden class="anchor" aria-hidden="true" href="#102-二叉树的层序遍历">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a>
给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for a binary tree node.
</span><span style="color:#000080"> * type TreeNode struct {
</span><span style="color:#000080"> *     Val int
</span><span style="color:#000080"> *     Left *TreeNode
</span><span style="color:#000080"> *     Right *TreeNode
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>
<span style="color:#00cd00">func</span> levelOrder(root <span style="color:#39c">*</span>TreeNode) [][]<span style="color:#00cd00">int</span> {
    ans <span style="color:#39c">:=</span> [][]<span style="color:#00cd00">int</span>{}
    <span style="color:#cdcd00">if</span> root <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> ans
    }

    q <span style="color:#39c">:=</span> []<span style="color:#39c">*</span>TreeNode{root}
    <span style="color:#cdcd00">for</span> <span style="color:#cd00cd">len</span>(q) <span style="color:#39c">!=</span> <span style="color:#cd00cd">0</span> {
        level <span style="color:#39c">:=</span> []<span style="color:#00cd00">int</span>{}
        size <span style="color:#39c">:=</span> <span style="color:#cd00cd">len</span>(q)
        <span style="color:#cdcd00">for</span> i <span style="color:#39c">:=</span> <span style="color:#cd00cd">0</span>; i &lt; size; i<span style="color:#39c">++</span> {
            level = <span style="color:#cd00cd">append</span>(level, q[i].Val)
            <span style="color:#cdcd00">if</span> q[i].Left <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
                q = <span style="color:#cd00cd">append</span>(q, q[i].Left)
            }
            <span style="color:#cdcd00">if</span> q[i].Right <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
                q = <span style="color:#cd00cd">append</span>(q, q[i].Right)
            }
        }
        ans = <span style="color:#cd00cd">append</span>(ans, level)
        q = q[size:]
    }
    <span style="color:#cdcd00">return</span> ans
}
</code></pre></div><h3 id="101-对称二叉树">101. 对称二叉树<a hidden class="anchor" aria-hidden="true" href="#101-对称二叉树">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a>
给你一个二叉树的根节点 root ， 检查它是否轴对称。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00cd00">func</span> isSymmetric(root <span style="color:#39c">*</span>TreeNode) <span style="color:#00cd00">bool</span> {
    <span style="color:#cdcd00">return</span> check(root, root)
}

<span style="color:#00cd00">func</span> check(left <span style="color:#39c">*</span>TreeNode, right <span style="color:#39c">*</span>TreeNode) <span style="color:#00cd00">bool</span> {
    <span style="color:#cdcd00">if</span> left <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> <span style="color:#39c">&amp;&amp;</span> right <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">true</span>
    }

    <span style="color:#cdcd00">if</span> left <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> <span style="color:#39c">||</span> right <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">false</span>
    }

    <span style="color:#cdcd00">if</span> left.Val <span style="color:#39c">!=</span> right.Val {
        <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">false</span>
    }

    <span style="color:#cdcd00">return</span> check(left.Left, right.Right) <span style="color:#39c">&amp;&amp;</span> check(left.Right, right.Left) 
}
</code></pre></div><h3 id="98-验证二叉搜索树">98. 验证二叉搜索树<a hidden class="anchor" aria-hidden="true" href="#98-验证二叉搜索树">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a>
给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<p>节点的左子树只包含 小于 当前节点的数。
节点的右子树只包含 大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00cd00">func</span> isValidBST(root <span style="color:#39c">*</span>TreeNode) <span style="color:#00cd00">bool</span> {
    <span style="color:#cdcd00">return</span> f(root, math.MinInt64, math.MaxInt64)
}

<span style="color:#00cd00">func</span> f(root <span style="color:#39c">*</span>TreeNode, min <span style="color:#00cd00">int64</span>, max <span style="color:#00cd00">int64</span>) <span style="color:#00cd00">bool</span> {
    <span style="color:#cdcd00">if</span> root <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">true</span>
    }

    <span style="color:#cdcd00">if</span> <span style="color:#cd00cd">int64</span>(root.Val) <span style="color:#39c">&lt;=</span> min <span style="color:#39c">||</span> <span style="color:#cd00cd">int64</span>(root.Val) <span style="color:#39c">&gt;=</span> max {
        <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">false</span>
    }

    <span style="color:#cdcd00">return</span> f(root.Left, min, <span style="color:#cd00cd">int64</span>(root.Val)) <span style="color:#39c">&amp;&amp;</span> f(root.Right, <span style="color:#cd00cd">int64</span>(root.Val), max)
}
</code></pre></div><h3 id="96-不同的二叉搜索树">96. 不同的二叉搜索树<a hidden class="anchor" aria-hidden="true" href="#96-不同的二叉搜索树">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a>
给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#00cd00">class</span> <span style="color:#00cdcd">Solution</span> <span style="color:#39c">{</span>
    <span style="color:#00cd00">public</span> <span style="color:#00cd00">int</span> numTrees<span style="color:#39c">(</span><span style="color:#00cd00">int</span> n<span style="color:#39c">)</span> <span style="color:#39c">{</span>
        <span style="color:#000080">// 状态 节点数
</span><span style="color:#000080"></span>        <span style="color:#000080">// 选择 选择哪个节点作为根节点
</span><span style="color:#000080"></span>  
        <span style="color:#000080">// 状态转移方程
</span><span style="color:#000080"></span>        <span style="color:#000080">// dp(n) 使用n个节点，能组成的二叉搜索树种数
</span><span style="color:#000080"></span>        <span style="color:#000080">// f(i, n) 使用i节点为根，能组成长度为n的二叉搜索树种数
</span><span style="color:#000080"></span>        <span style="color:#000080">// dp(n) = sum(f(i, n)), i属于1到n
</span><span style="color:#000080"></span>        <span style="color:#000080">// f(i, n) = dp(i - 1) * dp(n - i)
</span><span style="color:#000080"></span>        <span style="color:#000080">// dp(n) = sum(dp(i - 1) * dp(n - i)), i属于1到n
</span><span style="color:#000080"></span>
        <span style="color:#000080">// baseCase 
</span><span style="color:#000080"></span>        <span style="color:#000080">// dp[0] = 0
</span><span style="color:#000080"></span>        <span style="color:#000080">// dp[1] = 1
</span><span style="color:#000080"></span>        <span style="color:#000080">// dp[2] = 2
</span><span style="color:#000080"></span>        <span style="color:#000080">// dp[3] = 5
</span><span style="color:#000080"></span>
        <span style="color:#00cd00">int</span><span style="color:#39c">[]</span> dp <span style="color:#39c">=</span> <span style="color:#cdcd00">new</span> <span style="color:#00cd00">int</span><span style="color:#39c">[</span>n <span style="color:#39c">+</span> 1<span style="color:#39c">];</span>
        dp<span style="color:#39c">[</span>0<span style="color:#39c">]</span> <span style="color:#39c">=</span> 1<span style="color:#39c">;</span>
        dp<span style="color:#39c">[</span>1<span style="color:#39c">]</span> <span style="color:#39c">=</span> 1<span style="color:#39c">;</span>

        <span style="color:#cdcd00">for</span> <span style="color:#39c">(</span><span style="color:#00cd00">int</span> i <span style="color:#39c">=</span> 2<span style="color:#39c">;</span> i <span style="color:#39c">&lt;=</span> n<span style="color:#39c">;</span> i<span style="color:#39c">++)</span> <span style="color:#39c">{</span>
            <span style="color:#cdcd00">for</span> <span style="color:#39c">(</span><span style="color:#00cd00">int</span> j <span style="color:#39c">=</span> 1<span style="color:#39c">;</span> j <span style="color:#39c">&lt;=</span> i<span style="color:#39c">;</span> j<span style="color:#39c">++)</span> <span style="color:#39c">{</span>
                dp<span style="color:#39c">[</span>i<span style="color:#39c">]</span> <span style="color:#39c">+=</span> dp<span style="color:#39c">[</span>j <span style="color:#39c">-</span> 1<span style="color:#39c">]</span> <span style="color:#39c">*</span> dp<span style="color:#39c">[</span>i <span style="color:#39c">-</span> j<span style="color:#39c">];</span>
            <span style="color:#39c">}</span>
        <span style="color:#39c">}</span>

        <span style="color:#cdcd00">return</span> dp<span style="color:#39c">[</span>n<span style="color:#39c">];</span>
    <span style="color:#39c">}</span>
<span style="color:#39c">}</span>
</code></pre></div><h3 id="94-二叉树的中序遍历">94. 二叉树的中序遍历<a hidden class="anchor" aria-hidden="true" href="#94-二叉树的中序遍历">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a>
给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for a binary tree node.
</span><span style="color:#000080"> * type TreeNode struct {
</span><span style="color:#000080"> *     Val int
</span><span style="color:#000080"> *     Left *TreeNode
</span><span style="color:#000080"> *     Right *TreeNode
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>

<span style="color:#000080">// 递归
</span><span style="color:#000080"></span><span style="color:#00cd00">func</span> inorderTraversal(root <span style="color:#39c">*</span>TreeNode) []<span style="color:#00cd00">int</span> {
    ans <span style="color:#39c">:=</span> []<span style="color:#00cd00">int</span>{}
    <span style="color:#00cd00">var</span> r <span style="color:#00cd00">func</span>(root <span style="color:#39c">*</span>TreeNode)
    r = <span style="color:#00cd00">func</span>(root <span style="color:#39c">*</span>TreeNode) {
        <span style="color:#cdcd00">if</span> root <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
            <span style="color:#cdcd00">return</span>
        }
        r(root.Left)
        ans = <span style="color:#cd00cd">append</span>(ans, root.Val)
        r(root.Right)
    }
    r(root)
    <span style="color:#cdcd00">return</span> ans
}

<span style="color:#000080">// 迭代
</span><span style="color:#000080"></span><span style="color:#00cd00">func</span> inorderTraversal2(root <span style="color:#39c">*</span>TreeNode) []<span style="color:#00cd00">int</span> {
    <span style="color:#cdcd00">if</span> root <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> []<span style="color:#00cd00">int</span>{}
    }
    <span style="color:#000080">// 核心思想要用栈模拟
</span><span style="color:#000080"></span>    stack <span style="color:#39c">:=</span> []<span style="color:#39c">*</span>TreeNode{}
    ans <span style="color:#39c">:=</span> []<span style="color:#00cd00">int</span>{}
    curr <span style="color:#39c">:=</span> root <span style="color:#000080">// 用来指向当前操作的节点
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">for</span> curr <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> <span style="color:#39c">||</span> <span style="color:#cd00cd">len</span>(stack) <span style="color:#39c">!=</span> <span style="color:#cd00cd">0</span> {
        <span style="color:#cdcd00">if</span> curr <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
            stack = <span style="color:#cd00cd">append</span>(stack, curr)
            curr = curr.Left
        } <span style="color:#cdcd00">else</span> {
            n <span style="color:#39c">:=</span> <span style="color:#cd00cd">len</span>(stack) <span style="color:#39c">-</span> <span style="color:#cd00cd">1</span>
            curr = stack[n]
            stack = stack[:n]
            ans = <span style="color:#cd00cd">append</span>(ans, curr.Val)
            curr = curr.Right
        }
    }
    <span style="color:#cdcd00">return</span> ans
}
</code></pre></div><h3 id="110-平衡二叉树">110. 平衡二叉树<a hidden class="anchor" aria-hidden="true" href="#110-平衡二叉树">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a>
给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for a binary tree node.
</span><span style="color:#000080"> * type TreeNode struct {
</span><span style="color:#000080"> *     Val int
</span><span style="color:#000080"> *     Left *TreeNode
</span><span style="color:#000080"> *     Right *TreeNode
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>
<span style="color:#00cd00">func</span> isBalanced(root <span style="color:#39c">*</span>TreeNode) <span style="color:#00cd00">bool</span> {
    h <span style="color:#39c">:=</span> height(root)
    <span style="color:#cdcd00">return</span> h <span style="color:#39c">!=</span> <span style="color:#39c">-</span><span style="color:#cd00cd">1</span>
}

<span style="color:#00cd00">func</span> height(root <span style="color:#39c">*</span>TreeNode) <span style="color:#00cd00">int</span> {
    <span style="color:#cdcd00">if</span> root <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> { <span style="color:#cdcd00">return</span> <span style="color:#cd00cd">0</span> }
    leftH <span style="color:#39c">:=</span> height(root.Left)
    rightH <span style="color:#39c">:=</span> height(root.Right)

    <span style="color:#cdcd00">if</span> leftH <span style="color:#39c">==</span> <span style="color:#39c">-</span><span style="color:#cd00cd">1</span> <span style="color:#39c">||</span> rightH <span style="color:#39c">==</span> <span style="color:#39c">-</span><span style="color:#cd00cd">1</span> <span style="color:#39c">||</span> abs(leftH <span style="color:#39c">-</span> rightH) &gt; <span style="color:#cd00cd">1</span> {
        <span style="color:#cdcd00">return</span> <span style="color:#39c">-</span><span style="color:#cd00cd">1</span> <span style="color:#000080">// -1代表不平衡，不需要再继续了
</span><span style="color:#000080"></span>    }

    <span style="color:#cdcd00">return</span> max(leftH, rightH) <span style="color:#39c">+</span> <span style="color:#cd00cd">1</span>
}
</code></pre></div><h3 id="129-求根节点到叶节点数字之和">129. 求根节点到叶节点数字之和<a hidden class="anchor" aria-hidden="true" href="#129-求根节点到叶节点数字之和">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和</a>
给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：</p>
<p>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。
计算从根节点到叶节点生成的 所有数字之和 。</p>
<p>叶节点 是指没有子节点的节点。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for a binary tree node.
</span><span style="color:#000080"> * type TreeNode struct {
</span><span style="color:#000080"> *     Val int
</span><span style="color:#000080"> *     Left *TreeNode
</span><span style="color:#000080"> *     Right *TreeNode
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>
<span style="color:#00cd00">func</span> sumNumbers(root <span style="color:#39c">*</span>TreeNode) <span style="color:#00cd00">int</span> {
    <span style="color:#cdcd00">if</span> root <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> { <span style="color:#cdcd00">return</span> <span style="color:#cd00cd">0</span> }

    <span style="color:#00cd00">var</span> dfs <span style="color:#00cd00">func</span>(root <span style="color:#39c">*</span>TreeNode, sum <span style="color:#00cd00">int</span>) <span style="color:#00cd00">int</span>
    dfs = <span style="color:#00cd00">func</span>(root <span style="color:#39c">*</span>TreeNode, sum <span style="color:#00cd00">int</span>) <span style="color:#00cd00">int</span> {
        <span style="color:#cdcd00">if</span> root <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
            <span style="color:#cdcd00">return</span> <span style="color:#cd00cd">0</span>
        }
        rootSum <span style="color:#39c">:=</span> root.Val <span style="color:#39c">+</span> sum <span style="color:#39c">*</span> <span style="color:#cd00cd">10</span>
        <span style="color:#cdcd00">if</span> root.Left <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> <span style="color:#39c">&amp;&amp;</span> root.Right <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
            <span style="color:#cdcd00">return</span> rootSum
        }

        leftSum <span style="color:#39c">:=</span> dfs(root.Left, rootSum)
        rightSum <span style="color:#39c">:=</span> dfs(root.Right, rootSum)

        <span style="color:#cdcd00">return</span> leftSum <span style="color:#39c">+</span> rightSum
    }
    <span style="color:#cdcd00">return</span> dfs(root, <span style="color:#cd00cd">0</span>)
}
</code></pre></div><h3 id="109-有序链表转换二叉搜索树">109. 有序链表转换二叉搜索树<a hidden class="anchor" aria-hidden="true" href="#109-有序链表转换二叉搜索树">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></p>
<p>思路：</p>
<ol>
<li>找到链表的中点，一分为二</li>
<li>中点为head，并且递归生成左右子树</li>
<li>当 <code>left == right</code> 时，证明已经构建完成（可以这么理解，left和right是左闭右开，当left==right时，证明left已经超过边界了）</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for singly-linked list.
</span><span style="color:#000080"> * type ListNode struct {
</span><span style="color:#000080"> *     Val int
</span><span style="color:#000080"> *     Next *ListNode
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>
<span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for a binary tree node.
</span><span style="color:#000080"> * type TreeNode struct {
</span><span style="color:#000080"> *     Val int
</span><span style="color:#000080"> *     Left *TreeNode
</span><span style="color:#000080"> *     Right *TreeNode
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>
<span style="color:#00cd00">func</span> sortedListToBST(head <span style="color:#39c">*</span>ListNode) <span style="color:#39c">*</span>TreeNode {
    <span style="color:#cdcd00">return</span> build(head, <span style="color:#cdcd00">nil</span>)
}

<span style="color:#00cd00">func</span> build(left <span style="color:#39c">*</span>ListNode, right <span style="color:#39c">*</span>ListNode) <span style="color:#39c">*</span>TreeNode {
    <span style="color:#cdcd00">if</span> left <span style="color:#39c">==</span> right {
        <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>
    }
    
    mid <span style="color:#39c">:=</span> findMid(left, right)
    head <span style="color:#39c">:=</span> <span style="color:#39c">&amp;</span>TreeNode{Val: mid.Val}
    head.Left = build(left, mid)
    head.Right = build(mid.Next, right)
    <span style="color:#cdcd00">return</span> head
}

<span style="color:#00cd00">func</span> findMid(left, right <span style="color:#39c">*</span>ListNode) <span style="color:#39c">*</span>ListNode {
    s, f <span style="color:#39c">:=</span> left, left
    <span style="color:#cdcd00">for</span> f <span style="color:#39c">!=</span> right <span style="color:#39c">&amp;&amp;</span> f.Next <span style="color:#39c">!=</span> right {
        s = s.Next
        f = f.Next.Next
    }
    <span style="color:#cdcd00">return</span> s
}
</code></pre></div><h3 id="450-删除二叉搜索树中的节点">450. 删除二叉搜索树中的节点<a hidden class="anchor" aria-hidden="true" href="#450-删除二叉搜索树中的节点">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></p>
<p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<p>首先找到需要删除的节点；
如果找到了，删除它。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for a binary tree node.
</span><span style="color:#000080"> * type TreeNode struct {
</span><span style="color:#000080"> *     Val int
</span><span style="color:#000080"> *     Left *TreeNode
</span><span style="color:#000080"> *     Right *TreeNode
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>
<span style="color:#00cd00">func</span> deleteNode(root <span style="color:#39c">*</span>TreeNode, key <span style="color:#00cd00">int</span>) <span style="color:#39c">*</span>TreeNode {
    <span style="color:#cdcd00">if</span> root <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>
    }

    <span style="color:#cdcd00">if</span> root.Val <span style="color:#39c">==</span> key {
        <span style="color:#000080">// 叶子节点，直接删除
</span><span style="color:#000080"></span>        <span style="color:#cdcd00">if</span> root.Left <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> <span style="color:#39c">&amp;&amp;</span> root.Right <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
            <span style="color:#000080">// 当前节点被删，返回空
</span><span style="color:#000080"></span>            <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>
        }

        <span style="color:#000080">// 左子树为空，右子树上来继位
</span><span style="color:#000080"></span>        <span style="color:#cdcd00">if</span> root.Left <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
            <span style="color:#cdcd00">return</span> root.Right
        }
        <span style="color:#000080">// 右子树为空，左子树上来继位
</span><span style="color:#000080"></span>        <span style="color:#cdcd00">if</span> root.Right <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
            <span style="color:#cdcd00">return</span> root.Left
        }
        <span style="color:#000080">// 左右都不为空，将左子树的头节点接到右子树里最左节点的左节点上
</span><span style="color:#000080"></span>        leftRoot <span style="color:#39c">:=</span> root.Left
        leftestNode <span style="color:#39c">:=</span> root.Right <span style="color:#000080">// 右子树里最左边的节点
</span><span style="color:#000080"></span>        <span style="color:#cdcd00">for</span> leftestNode.Left <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
            leftestNode = leftestNode.Left
        }
        leftestNode.Left = leftRoot
        <span style="color:#cdcd00">return</span> root.Right
    }

    <span style="color:#cdcd00">if</span> root.Val &lt; key {
        root.Right = deleteNode(root.Right, key)
    } <span style="color:#cdcd00">else</span> {
        root.Left = deleteNode(root.Left, key)
    }
    
    <span style="color:#cdcd00">return</span> root
}
</code></pre></div><h3 id="297-二叉树的序列化与反序列化">297. 二叉树的序列化与反序列化<a hidden class="anchor" aria-hidden="true" href="#297-二叉树的序列化与反序列化">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></p>
<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for a binary tree node.
</span><span style="color:#000080"> * type TreeNode struct {
</span><span style="color:#000080"> *     Val int
</span><span style="color:#000080"> *     Left *TreeNode
</span><span style="color:#000080"> *     Right *TreeNode
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>

<span style="color:#00cd00">type</span> Codec <span style="color:#00cd00">struct</span> {}

<span style="color:#00cd00">func</span> Constructor() Codec {
    c <span style="color:#39c">:=</span> Codec{}
    <span style="color:#cdcd00">return</span> c
}

<span style="color:#000080">// Serializes a tree to a single string.
</span><span style="color:#000080"></span><span style="color:#00cd00">func</span> (c <span style="color:#39c">*</span>Codec) serialize(root <span style="color:#39c">*</span>TreeNode) <span style="color:#00cd00">string</span> {
    ans <span style="color:#39c">:=</span> []<span style="color:#00cd00">string</span>{}
    q <span style="color:#39c">:=</span> []<span style="color:#39c">*</span>TreeNode {root}
    <span style="color:#cdcd00">for</span> <span style="color:#cd00cd">len</span>(q) <span style="color:#39c">!=</span> <span style="color:#cd00cd">0</span> {
        node <span style="color:#39c">:=</span> q[<span style="color:#cd00cd">0</span>]
        q = q[<span style="color:#cd00cd">1</span>:]

        <span style="color:#cdcd00">if</span> node <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
            ans = <span style="color:#cd00cd">append</span>(ans, strconv.Itoa(node.Val))
            q = <span style="color:#cd00cd">append</span>(q, node.Left)
            q = <span style="color:#cd00cd">append</span>(q, node.Right)
        } <span style="color:#cdcd00">else</span> {
            ans = <span style="color:#cd00cd">append</span>(ans, <span style="color:#cd0000">&#34;X&#34;</span>)
        }
    }
    <span style="color:#cdcd00">return</span> strings.Join(ans, <span style="color:#cd0000">&#34;,&#34;</span>)
}

<span style="color:#000080">// Deserializes your encoded data to tree.
</span><span style="color:#000080"></span><span style="color:#00cd00">func</span> (c <span style="color:#39c">*</span>Codec) deserialize(data <span style="color:#00cd00">string</span>) <span style="color:#39c">*</span>TreeNode {    
    <span style="color:#cdcd00">if</span> data <span style="color:#39c">==</span> <span style="color:#cd0000">&#34;X&#34;</span> { <span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span> } 
    nodes <span style="color:#39c">:=</span> strings.Split(data, <span style="color:#cd0000">&#34;,&#34;</span>)
    v, _ <span style="color:#39c">:=</span> strconv.Atoi(nodes[<span style="color:#cd00cd">0</span>])
    root <span style="color:#39c">:=</span> <span style="color:#39c">&amp;</span>TreeNode{Val: v}
    q <span style="color:#39c">:=</span> []<span style="color:#39c">*</span>TreeNode {root}
    curr <span style="color:#39c">:=</span> <span style="color:#cd00cd">1</span>

    <span style="color:#cdcd00">for</span> curr &lt; <span style="color:#cd00cd">len</span>(nodes) {
        node <span style="color:#39c">:=</span> q[<span style="color:#cd00cd">0</span>]
        q = q[<span style="color:#cd00cd">1</span>:]

        leftVal <span style="color:#39c">:=</span> nodes[curr]
        <span style="color:#cdcd00">if</span> leftVal <span style="color:#39c">!=</span> <span style="color:#cd0000">&#34;X&#34;</span> {
            _leftVal, _ <span style="color:#39c">:=</span> strconv.Atoi(leftVal)
            leftNode <span style="color:#39c">:=</span> <span style="color:#39c">&amp;</span>TreeNode{Val: _leftVal}
            node.Left = leftNode
            q = <span style="color:#cd00cd">append</span>(q, leftNode)
        }

        rightVal <span style="color:#39c">:=</span> nodes[curr<span style="color:#39c">+</span><span style="color:#cd00cd">1</span>]
        <span style="color:#cdcd00">if</span> rightVal <span style="color:#39c">!=</span> <span style="color:#cd0000">&#34;X&#34;</span> {
            _rightVal, _ <span style="color:#39c">:=</span> strconv.Atoi(rightVal)
            rightNode <span style="color:#39c">:=</span> <span style="color:#39c">&amp;</span>TreeNode{Val: _rightVal}
            node.Right = rightNode
            q = <span style="color:#cd00cd">append</span>(q, rightNode)
        }
        curr <span style="color:#39c">+=</span> <span style="color:#cd00cd">2</span>
    }

    <span style="color:#cdcd00">return</span> root
}

<span style="color:#000080">/**
</span><span style="color:#000080"> * Your Codec object will be instantiated and called as such:
</span><span style="color:#000080"> * ser := Constructor();
</span><span style="color:#000080"> * deser := Constructor();
</span><span style="color:#000080"> * data := ser.serialize(root);
</span><span style="color:#000080"> * ans := deser.deserialize(data);
</span><span style="color:#000080"> */</span>
</code></pre></div><h3 id="700-二叉搜索树中的搜索">700. 二叉搜索树中的搜索<a hidden class="anchor" aria-hidden="true" href="#700-二叉搜索树中的搜索">#</a></h3>
<p><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></p>
<p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。</p>
<p>你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">/**
</span><span style="color:#000080"> * Definition for a binary tree node.
</span><span style="color:#000080"> * type TreeNode struct {
</span><span style="color:#000080"> *     Val int
</span><span style="color:#000080"> *     Left *TreeNode
</span><span style="color:#000080"> *     Right *TreeNode
</span><span style="color:#000080"> * }
</span><span style="color:#000080"> */</span>
<span style="color:#00cd00">func</span> searchBST(root <span style="color:#39c">*</span>TreeNode, val <span style="color:#00cd00">int</span>) <span style="color:#39c">*</span>TreeNode {
    <span style="color:#cdcd00">if</span> root <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> <span style="color:#39c">||</span> root.Val <span style="color:#39c">==</span> val {
        <span style="color:#cdcd00">return</span> root
    }
    
    <span style="color:#cdcd00">if</span> val <span style="color:#39c">&lt;=</span> root.Val {
        <span style="color:#cdcd00">return</span> searchBST(root.Left, val)
    }
    
    <span style="color:#cdcd00">return</span> searchBST(root.Right, val)
}
</code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lambertxiao.github.io/tags/%E7%AE%97%E6%B3%95/">算法</a></li>
      <li><a href="https://lambertxiao.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://lambertxiao.github.io/posts/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-topk/doc/">
    <span class="title">« Prev Page</span>
    <br>
    <span>算法-topK</span>
  </a>
  <a class="next" href="https://lambertxiao.github.io/posts/golang/golang-%E4%BD%8D%E8%BF%90%E7%AE%97/doc/">
    <span class="title">Next Page »</span>
    <br>
    <span>算法-位运算</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share 算法-二叉树 on twitter"
        href="https://twitter.com/intent/tweet/?text=%e7%ae%97%e6%b3%95-%e4%ba%8c%e5%8f%89%e6%a0%91&amp;url=https%3a%2f%2flambertxiao.github.io%2fposts%2f%25E7%25AE%2597%25E6%25B3%2595%2f%25E7%25AE%2597%25E6%25B3%2595-%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2fdoc%2f&amp;hashtags=%e7%ae%97%e6%b3%95%2c%e4%ba%8c%e5%8f%89%e6%a0%91">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 算法-二叉树 on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flambertxiao.github.io%2fposts%2f%25E7%25AE%2597%25E6%25B3%2595%2f%25E7%25AE%2597%25E6%25B3%2595-%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2fdoc%2f&amp;title=%e7%ae%97%e6%b3%95-%e4%ba%8c%e5%8f%89%e6%a0%91&amp;summary=%e7%ae%97%e6%b3%95-%e4%ba%8c%e5%8f%89%e6%a0%91&amp;source=https%3a%2f%2flambertxiao.github.io%2fposts%2f%25E7%25AE%2597%25E6%25B3%2595%2f%25E7%25AE%2597%25E6%25B3%2595-%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2fdoc%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 算法-二叉树 on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2flambertxiao.github.io%2fposts%2f%25E7%25AE%2597%25E6%25B3%2595%2f%25E7%25AE%2597%25E6%25B3%2595-%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2fdoc%2f&title=%e7%ae%97%e6%b3%95-%e4%ba%8c%e5%8f%89%e6%a0%91">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 算法-二叉树 on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flambertxiao.github.io%2fposts%2f%25E7%25AE%2597%25E6%25B3%2595%2f%25E7%25AE%2597%25E6%25B3%2595-%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2fdoc%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 算法-二叉树 on whatsapp"
        href="https://api.whatsapp.com/send?text=%e7%ae%97%e6%b3%95-%e4%ba%8c%e5%8f%89%e6%a0%91%20-%20https%3a%2f%2flambertxiao.github.io%2fposts%2f%25E7%25AE%2597%25E6%25B3%2595%2f%25E7%25AE%2597%25E6%25B3%2595-%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2fdoc%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share 算法-二叉树 on telegram"
        href="https://telegram.me/share/url?text=%e7%ae%97%e6%b3%95-%e4%ba%8c%e5%8f%89%e6%a0%91&amp;url=https%3a%2f%2flambertxiao.github.io%2fposts%2f%25E7%25AE%2597%25E6%25B3%2595%2f%25E7%25AE%2597%25E6%25B3%2595-%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%2fdoc%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer><div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "disqus_KY25sRiRtb" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://lambertxiao.github.io">Lambert&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
