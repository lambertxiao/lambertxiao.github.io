<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Golang-epoll | Lambert&#39;s blog</title>
<meta name="keywords" content="golang" />
<meta name="description" content="go怎么用的epoll">
<meta name="author" content="Lambert Xiao">
<link rel="canonical" href="https://lambertxiao.github.io/posts/golang/golang-epoll/doc/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.f930089bcedc85892fe03ed179c7aff545249b87bdabbcac09cc1895e74257eb.css" integrity="sha256-&#43;TAIm87chYkv4D7Recev9UUkm4e9q7ysCcwYledCV&#43;s=" rel="preload stylesheet" as="style">
<link rel="preload" href="/avatar.jpeg" as="image">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://lambertxiao.github.io/avatar.jpeg">
<link rel="icon" type="image/png" sizes="16x16" href="https://lambertxiao.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lambertxiao.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lambertxiao.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lambertxiao.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Golang-epoll" />
<meta property="og:description" content="go怎么用的epoll" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lambertxiao.github.io/posts/golang/golang-epoll/doc/" /><meta property="og:image" content="https://lambertxiao.github.io/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-24T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2022-03-24T00:00:00&#43;00:00" />
<meta property="og:see_also" content="https://lambertxiao.github.io/posts/gdb_usage/doc/" /><meta property="og:see_also" content="https://lambertxiao.github.io/posts/numa/doc/" /><meta property="og:see_also" content="https://lambertxiao.github.io/posts/uio/doc/" /><meta property="og:see_also" content="https://lambertxiao.github.io/posts/vfio/doc/" /><meta property="og:see_also" content="https://lambertxiao.github.io/posts/virtio/doc/" /><meta property="og:see_also" content="https://lambertxiao.github.io/posts/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/doc/" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://lambertxiao.github.io/papermod-cover.png"/>

<meta name="twitter:title" content="Golang-epoll"/>
<meta name="twitter:description" content="go怎么用的epoll"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://lambertxiao.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Golang-epoll",
      "item": "https://lambertxiao.github.io/posts/golang/golang-epoll/doc/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Golang-epoll",
  "name": "Golang-epoll",
  "description": "go怎么用的epoll",
  "keywords": [
    "golang"
  ],
  "articleBody": "例子 func main() { lister, err := net.Listen(\"tcp\", \"0.0.0.0:9009\") if err != nil { return } for { conn, err := lister.Accept() //等待建立连接  if err != nil { continue } //开启协程处理  go func() { defer conn.Close() for { buf := make([]byte, 128) n, err := conn.Read(buf) if err != nil{ return } } }() } } Listen func Listen(network, address string) (Listener, error) { var lc ListenConfig return lc.Listen(context.Background(), network, address) } func (lc *ListenConfig) Listen(ctx context.Context, network, address string) (Listener, error) { addrs, err := DefaultResolver.resolveAddrList(ctx, \"listen\", network, address, nil) if err != nil { return nil, \u0026OpError{Op: \"listen\", Net: network, Source: nil, Addr: nil, Err: err} } sl := \u0026sysListener{ ListenConfig: *lc, network: network, address: address, } var l Listener la := addrs.first(isIPv4) switch la := la.(type) { case *TCPAddr: l, err = sl.listenTCP(ctx, la) case *UnixAddr: l, err = sl.listenUnix(ctx, la) default: return nil, \u0026OpError{Op: \"listen\", Net: sl.network, Source: nil, Addr: la, Err: \u0026AddrError{Err: \"unexpected address type\", Addr: address}} } if err != nil { return nil, \u0026OpError{Op: \"listen\", Net: sl.network, Source: nil, Addr: la, Err: err} // l is non-nil interface containing nil pointer \t} return l, nil } func (sl *sysListener) listenTCP(ctx context.Context, laddr *TCPAddr) (*TCPListener, error) { fd, err := internetSocket(ctx, sl.network, laddr, nil, syscall.SOCK_STREAM, 0, \"listen\", sl.ListenConfig.Control) if err != nil { return nil, err } return \u0026TCPListener{fd: fd, lc: sl.ListenConfig}, nil } func internetSocket(ctx context.Context, net string, laddr, raddr sockaddr, sotype, proto int, mode string, ctrlFn func(string, string, syscall.RawConn) error) (fd *netFD, err error) { if (runtime.GOOS == \"aix\" || runtime.GOOS == \"windows\" || runtime.GOOS == \"openbsd\") \u0026\u0026 mode == \"dial\" \u0026\u0026 raddr.isWildcard() { raddr = raddr.toLocal(net) } family, ipv6only := favoriteAddrFamily(net, laddr, raddr, mode) return socket(ctx, net, family, sotype, proto, ipv6only, laddr, raddr, ctrlFn) } // socket returns a network file descriptor that is ready for // asynchronous I/O using the network poller. func socket(ctx context.Context, net string, family, sotype, proto int, ipv6only bool, laddr, raddr sockaddr, ctrlFn func(string, string, syscall.RawConn) error) (fd *netFD, err error) { s, err := sysSocket(family, sotype, proto) if err != nil { return nil, err } if err = setDefaultSockopts(s, family, sotype, ipv6only); err != nil { poll.CloseFunc(s) return nil, err } if fd, err = newFD(s, family, sotype, net); err != nil { poll.CloseFunc(s) return nil, err } // This function makes a network file descriptor for the \t// following applications: \t// \t// - An endpoint holder that opens a passive stream \t// connection, known as a stream listener \t// \t// - An endpoint holder that opens a destination-unspecific \t// datagram connection, known as a datagram listener \t// \t// - An endpoint holder that opens an active stream or a \t// destination-specific datagram connection, known as a \t// dialer \t// \t// - An endpoint holder that opens the other connection, such \t// as talking to the protocol stack inside the kernel \t// \t// For stream and datagram listeners, they will only require \t// named sockets, so we can assume that it's just a request \t// from stream or datagram listeners when laddr is not nil but \t// raddr is nil. Otherwise we assume it's just for dialers or \t// the other connection holders.  if laddr != nil \u0026\u0026 raddr == nil { switch sotype { case syscall.SOCK_STREAM, syscall.SOCK_SEQPACKET: if err := fd.listenStream(laddr, listenerBacklog(), ctrlFn); err != nil { fd.Close() return nil, err } return fd, nil case syscall.SOCK_DGRAM: if err := fd.listenDatagram(laddr, ctrlFn); err != nil { fd.Close() return nil, err } return fd, nil } } if err := fd.dial(ctx, laddr, raddr, ctrlFn); err != nil { fd.Close() return nil, err } return fd, nil } func sysSocket(family, sotype, proto int) (int, error) { // See ../syscall/exec_unix.go for description of ForkLock. \tsyscall.ForkLock.RLock() s, err := socketFunc(family, sotype, proto) if err == nil { syscall.CloseOnExec(s) } syscall.ForkLock.RUnlock() if err != nil { return -1, os.NewSyscallError(\"socket\", err) } if err = syscall.SetNonblock(s, true); err != nil { poll.CloseFunc(s) return -1, os.NewSyscallError(\"setnonblock\", err) } return s, nil } func (fd *netFD) listenStream(laddr sockaddr, backlog int, ctrlFn func(string, string, syscall.RawConn) error) error { var err error if err = setDefaultListenerSockopts(fd.pfd.Sysfd); err != nil { return err } var lsa syscall.Sockaddr if lsa, err = laddr.sockaddr(fd.family); err != nil { return err } if ctrlFn != nil { c, err := newRawConn(fd) if err != nil { return err } if err := ctrlFn(fd.ctrlNetwork(), laddr.String(), c); err != nil { return err } } if err = syscall.Bind(fd.pfd.Sysfd, lsa); err != nil { return os.NewSyscallError(\"bind\", err) } if err = listenFunc(fd.pfd.Sysfd, backlog); err != nil { return os.NewSyscallError(\"listen\", err) } if err = fd.init(); err != nil { return err } lsa, _ = syscall.Getsockname(fd.pfd.Sysfd) fd.setAddr(fd.addrFunc()(lsa), nil) return nil } func (fd *netFD) init() error { return fd.pfd.Init(fd.net, true) } // Init initializes the FD. The Sysfd field should already be set. // This can be called multiple times on a single FD. // The net argument is a network name from the net package (e.g., \"tcp\"), // or \"file\". // Set pollable to true if fd should be managed by runtime netpoll. func (fd *FD) Init(net string, pollable bool) error { // We don't actually care about the various network types. \tif net == \"file\" { fd.isFile = true } if !pollable { fd.isBlocking = 1 return nil } err := fd.pd.init(fd) if err != nil { // If we could not initialize the runtime poller, \t// assume we are using blocking mode. \tfd.isBlocking = 1 } return err } func (pd *pollDesc) init(fd *FD) error { serverInit.Do(runtime_pollServerInit) ctx, errno := runtime_pollOpen(uintptr(fd.Sysfd)) if errno != 0 { if ctx != 0 { runtime_pollUnblock(ctx) runtime_pollClose(ctx) } return errnoErr(syscall.Errno(errno)) } pd.runtimeCtx = ctx return nil } func runtime_pollServerInit() func runtime_pollOpen(fd uintptr) (uintptr, int) func runtime_pollClose(ctx uintptr) func runtime_pollWait(ctx uintptr, mode int) int func runtime_pollWaitCanceled(ctx uintptr, mode int) int func runtime_pollReset(ctx uintptr, mode int) int func runtime_pollSetDeadline(ctx uintptr, d int64, mode int) func runtime_pollUnblock(ctx uintptr) func runtime_isPollServerDescriptor(fd uintptr) bool //go:linkname poll_runtime_pollOpen internal/poll.runtime_pollOpen func poll_runtime_pollOpen(fd uintptr) (*pollDesc, int) { pd := pollcache.alloc() lock(\u0026pd.lock) if pd.wg != 0 \u0026\u0026 pd.wg != pdReady { throw(\"runtime: blocked write on free polldesc\") } if pd.rg != 0 \u0026\u0026 pd.rg != pdReady { throw(\"runtime: blocked read on free polldesc\") } pd.fd = fd pd.closing = false pd.everr = false pd.rseq++ pd.rg = 0 pd.rd = 0 pd.wseq++ pd.wg = 0 pd.wd = 0 pd.self = pd unlock(\u0026pd.lock) var errno int32 errno = netpollopen(fd, pd) return pd, int(errno) } func netpollopen(fd uintptr, pd *pollDesc) int32 { var ev epollevent ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET *(**pollDesc)(unsafe.Pointer(\u0026ev.data)) = pd return -epollctl(epfd, _EPOLL_CTL_ADD, int32(fd), \u0026ev) } Accpet // Accept implements the Accept method in the Listener interface; it // waits for the next call and returns a generic Conn. func (l *TCPListener) Accept() (Conn, error) { if !l.ok() { return nil, syscall.EINVAL } c, err := l.accept() if err != nil { return nil, \u0026OpError{Op: \"accept\", Net: l.fd.net, Source: nil, Addr: l.fd.laddr, Err: err} } return c, nil } func (ln *TCPListener) accept() (*TCPConn, error) { fd, err := ln.fd.accept() if err != nil { return nil, err } tc := newTCPConn(fd) if ln.lc.KeepAlive = 0 { setKeepAlive(fd, true) ka := ln.lc.KeepAlive if ln.lc.KeepAlive == 0 { ka = defaultTCPKeepAlive } setKeepAlivePeriod(fd, ka) } return tc, nil } func (fd *netFD) accept() (netfd *netFD, err error) { d, rsa, errcall, err := fd.pfd.Accept() if err != nil { if errcall != \"\" { err = wrapSyscallError(errcall, err) } return nil, err } if netfd, err = newFD(d, fd.family, fd.sotype, fd.net); err != nil { poll.CloseFunc(d) return nil, err } if err = netfd.init(); err != nil { netfd.Close() return nil, err } lsa, _ := syscall.Getsockname(netfd.pfd.Sysfd) netfd.setAddr(netfd.addrFunc()(lsa), netfd.addrFunc()(rsa)) return netfd, nil } // Accept wraps the accept network call. func (fd *FD) Accept() (int, syscall.Sockaddr, string, error) { if err := fd.readLock(); err != nil { return -1, nil, \"\", err } defer fd.readUnlock() if err := fd.pd.prepareRead(fd.isFile); err != nil { return -1, nil, \"\", err } for { s, rsa, errcall, err := accept(fd.Sysfd) if err == nil { return s, rsa, \"\", err } switch err { case syscall.EINTR: continue case syscall.EAGAIN: if fd.pd.pollable() { if err = fd.pd.waitRead(fd.isFile); err == nil { continue } } case syscall.ECONNABORTED: // This means that a socket on the listen \t// queue was closed before we Accept()ed it; \t// it's a silly error, so try again. \tcontinue } return -1, nil, errcall, err } } func (pd *pollDesc) pollable() bool { return pd.runtimeCtx != 0 } func (pd *pollDesc) waitRead(isFile bool) error { return pd.wait('r', isFile) } func (pd *pollDesc) wait(mode int, isFile bool) error { if pd.runtimeCtx == 0 { return errors.New(\"waiting for unsupported file type\") } res := runtime_pollWait(pd.runtimeCtx, mode) return convertErr(res, isFile) } func poll_runtime_pollWait(pd *pollDesc, mode int) int { errcode := netpollcheckerr(pd, int32(mode)) if errcode != pollNoError { return errcode } // As for now only Solaris, illumos, and AIX use level-triggered IO. \tif GOOS == \"solaris\" || GOOS == \"illumos\" || GOOS == \"aix\" { netpollarm(pd, mode) } for !netpollblock(pd, int32(mode), false) { errcode = netpollcheckerr(pd, int32(mode)) if errcode != pollNoError { return errcode } // Can happen if timeout has fired and unblocked us, \t// but before we had a chance to run, timeout has been reset. \t// Pretend it has not happened and retry. \t} return pollNoError } // returns true if IO is ready, or false if timedout or closed // waitio - wait only for completed IO, ignore errors func netpollblock(pd *pollDesc, mode int32, waitio bool) bool { gpp := \u0026pd.rg if mode == 'w' { gpp = \u0026pd.wg } // set the gpp semaphore to pdWait \tfor { old := *gpp if old == pdReady { *gpp = 0 return true } if old != 0 { throw(\"runtime: double wait\") } if atomic.Casuintptr(gpp, 0, pdWait) { break } } // need to recheck error states after setting gpp to pdWait \t// this is necessary because runtime_pollUnblock/runtime_pollSetDeadline/deadlineimpl \t// do the opposite: store to closing/rd/wd, membarrier, load of rg/wg \tif waitio || netpollcheckerr(pd, mode) == 0 { gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, 5) } // be careful to not lose concurrent pdReady notification \told := atomic.Xchguintptr(gpp, 0) if old  pdWait { throw(\"runtime: corrupted polldesc\") } return old == pdReady } // Puts the current goroutine into a waiting state and calls unlockf on the // system stack. // // If unlockf returns false, the goroutine is resumed. // // unlockf must not access this G's stack, as it may be moved between // the call to gopark and the call to unlockf. // // Note that because unlockf is called after putting the G into a waiting // state, the G may have already been readied by the time unlockf is called // unless there is external synchronization preventing the G from being // readied. If unlockf returns false, it must guarantee that the G cannot be // externally readied. // // Reason explains why the goroutine has been parked. It is displayed in stack // traces and heap dumps. Reasons should be unique and descriptive. Do not // re-use reasons, add new ones. func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int) { if reason != waitReasonSleep { checkTimeouts() // timeouts may expire while two goroutines keep the scheduler busy \t} mp := acquirem() gp := mp.curg status := readgstatus(gp) if status != _Grunning \u0026\u0026 status != _Gscanrunning { throw(\"gopark: bad g status\") } mp.waitlock = lock mp.waitunlockf = unlockf gp.waitreason = reason mp.waittraceev = traceEv mp.waittraceskip = traceskip releasem(mp) // can't do anything that might move the G between Ms here. \tmcall(park_m) } 唤醒 func sysmon() { lock(\u0026sched.lock) sched.nmsys++ checkdead() unlock(\u0026sched.lock) // For syscall_runtime_doAllThreadsSyscall, sysmon is \t// sufficiently up to participate in fixups. \tatomic.Store(\u0026sched.sysmonStarting, 0) lasttrace := int64(0) idle := 0 // how many cycles in succession we had not wokeup somebody \tdelay := uint32(0) for { if idle == 0 { // start with 20us sleep... \tdelay = 20 } else if idle  50 { // start doubling the sleep after 1ms... \tdelay *= 2 } if delay  10*1000 { // up to 10ms \tdelay = 10 * 1000 } usleep(delay) mDoFixup() // sysmon should not enter deep sleep if schedtrace is enabled so that \t// it can print that information at the right time. \t// \t// It should also not enter deep sleep if there are any active P's so \t// that it can retake P's from syscalls, preempt long running G's, and \t// poll the network if all P's are busy for long stretches. \t// \t// It should wakeup from deep sleep if any P's become active either due \t// to exiting a syscall or waking up due to a timer expiring so that it \t// can resume performing those duties. If it wakes from a syscall it \t// resets idle and delay as a bet that since it had retaken a P from a \t// syscall before, it may need to do it again shortly after the \t// application starts work again. It does not reset idle when waking \t// from a timer to avoid adding system load to applications that spend \t// most of their time sleeping. \tnow := nanotime() if debug.schedtrace  0 \u0026\u0026 (sched.gcwaiting != 0 || atomic.Load(\u0026sched.npidle) == uint32(gomaxprocs)) { lock(\u0026sched.lock) if atomic.Load(\u0026sched.gcwaiting) != 0 || atomic.Load(\u0026sched.npidle) == uint32(gomaxprocs) { syscallWake := false next, _ := timeSleepUntil() if next  now { atomic.Store(\u0026sched.sysmonwait, 1) unlock(\u0026sched.lock) // Make wake-up period small enough \t// for the sampling to be correct. \tsleep := forcegcperiod / 2 if next-now - now } shouldRelax := sleep = osRelaxMinNS if shouldRelax { osRelax(true) } syscallWake = notetsleep(\u0026sched.sysmonnote, sleep) mDoFixup() if shouldRelax { osRelax(false) } lock(\u0026sched.lock) atomic.Store(\u0026sched.sysmonwait, 0) noteclear(\u0026sched.sysmonnote) } if syscallWake { idle = 0 delay = 20 } } unlock(\u0026sched.lock) } lock(\u0026sched.sysmonlock) // Update now in case we blocked on sysmonnote or spent a long time \t// blocked on schedlock or sysmonlock above. \tnow = nanotime() // trigger libc interceptors if needed \tif *cgo_yield != nil { asmcgocall(*cgo_yield, nil) } // poll network if not polled for more than 10ms \tlastpoll := int64(atomic.Load64(\u0026sched.lastpoll)) if netpollinited() \u0026\u0026 lastpoll != 0 \u0026\u0026 lastpoll+10*1000*1000 \u0026sched.lastpoll, uint64(lastpoll), uint64(now)) list := netpoll(0) // non-blocking - returns list of goroutines \tif !list.empty() { // Need to decrement number of idle locked M's \t// (pretending that one more is running) before injectglist. \t// Otherwise it can lead to the following situation: \t// injectglist grabs all P's but before it starts M's to run the P's, \t// another M returns from syscall, finishes running its G, \t// observes that there is no work to do and no other running M's \t// and reports deadlock. \tincidlelocked(-1) injectglist(\u0026list) incidlelocked(1) } } mDoFixup() if GOOS == \"netbsd\" { // netpoll is responsible for waiting for timer \t// expiration, so we typically don't have to worry \t// about starting an M to service timers. (Note that \t// sleep for timeSleepUntil above simply ensures sysmon \t// starts running again when that timer expiration may \t// cause Go code to run again). \t// \t// However, netbsd has a kernel bug that sometimes \t// misses netpollBreak wake-ups, which can lead to \t// unbounded delays servicing timers. If we detect this \t// overrun, then startm to get something to handle the \t// timer. \t// \t// See issue 42515 and \t// https://gnats.netbsd.org/cgi-bin/query-pr-single.pl?number=50094. \tif next, _ := timeSleepUntil(); next nil, false) } } if atomic.Load(\u0026scavenge.sysmonWake) != 0 { // Kick the scavenger awake if someone requested it. \twakeScavenger() } // retake P's blocked in syscalls \t// and preempt long running G's \tif retake(now) != 0 { idle = 0 } else { idle++ } // check if we need to force a GC \tif t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() \u0026\u0026 atomic.Load(\u0026forcegc.idle) != 0 { lock(\u0026forcegc.lock) forcegc.idle = 0 var list gList list.push(forcegc.g) injectglist(\u0026list) unlock(\u0026forcegc.lock) } if debug.schedtrace  0 \u0026\u0026 lasttrace+int64(debug.schedtrace)*1000000  now { lasttrace = now schedtrace(debug.scheddetail  0) } unlock(\u0026sched.sysmonlock) } } Read // Read implements io.Reader. func (fd *FD) Read(p []byte) (int, error) { if err := fd.readLock(); err != nil { return 0, err } defer fd.readUnlock() if len(p) == 0 { // If the caller wanted a zero byte read, return immediately \t// without trying (but after acquiring the readLock). \t// Otherwise syscall.Read returns 0, nil which looks like \t// io.EOF. \t// TODO(bradfitz): make it wait for readability? (Issue 15735) \treturn 0, nil } if err := fd.pd.prepareRead(fd.isFile); err != nil { return 0, err } if fd.IsStream \u0026\u0026 len(p)  maxRW { p = p[:maxRW] } for { n, err := ignoringEINTRIO(syscall.Read, fd.Sysfd, p) if err != nil { n = 0 if err == syscall.EAGAIN \u0026\u0026 fd.pd.pollable() { if err = fd.pd.waitRead(fd.isFile); err == nil { continue } } } err = fd.eofError(n, err) return n, err } } Write // Write implements io.Writer. func (fd *FD) Write(p []byte) (int, error) { if err := fd.writeLock(); err != nil { return 0, err } defer fd.writeUnlock() if err := fd.pd.prepareWrite(fd.isFile); err != nil { return 0, err } var nn int for { max := len(p) if fd.IsStream \u0026\u0026 max-nn  maxRW { max = nn + maxRW } n, err := ignoringEINTRIO(syscall.Write, fd.Sysfd, p[nn:max]) if n  0 { nn += n } if nn == len(p) { return nn, err } if err == syscall.EAGAIN \u0026\u0026 fd.pd.pollable() { if err = fd.pd.waitWrite(fd.isFile); err == nil { continue } } if err != nil { return nn, err } if n == 0 { return nn, io.ErrUnexpectedEOF } } }  /go/src/runtime/netpoll.go\n 定义了几个抽象方法\n// Initialize the poller. Only called once. func netpollinit() // Arm edge-triggered notifications for fd. The pd argument is to pass // back to netpollready when fd is ready. Return an errno value. func netpollopen(fd uintptr, pd *pollDesc) int32 // Poll the network. If delta // poll without blocking. If delta  0, block for up to delta nanoseconds. // Return a list of goroutines built by calling netpollready. func netpoll(delta int64) gList // Wake up the network poller, assumed to be blocked in netpoll. func netpollBreak() // Reports whether fd is a file descriptor used by the poller. func netpollIsPollDescriptor(fd uintptr) bool 分平台实现\n netpoll.go netpoll_aix.go netpoll_epoll.go netpoll_fake.go netpoll_kqueue.go netpoll_os_test.go netpoll_solaris.go netpoll_stub.go netpoll_windows.go  看linux怎么做的\n",
  "wordCount" : "3061",
  "inLanguage": "en",
  "datePublished": "2022-03-24T00:00:00Z",
  "dateModified": "2022-03-24T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Lambert Xiao"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lambertxiao.github.io/posts/golang/golang-epoll/doc/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Lambert's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lambertxiao.github.io/avatar.jpeg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lambertxiao.github.io" accesskey="h" title="Lambert&#39;s Blog (Alt + H)">
                <img src="https://lambertxiao.github.io/avatar.jpeg" alt="logo" aria-label="logo"
                    height="35">Lambert&#39;s Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lambertxiao.github.io/archives" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="https://lambertxiao.github.io/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="https://lambertxiao.github.io/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://lambertxiao.github.io">Home</a>&nbsp;»&nbsp;<a href="https://lambertxiao.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      Golang-epoll
    </h1>
    <div class="post-meta"><span title='2022-03-24 00:00:00 +0000 UTC'>March 24, 2022</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Lambert Xiao&nbsp;|&nbsp;<a href="https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content/posts/golang/golang-epoll/doc.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e4%be%8b%e5%ad%90" aria-label="例子">例子</a></li>
                <li>
                    <a href="#listen" aria-label="Listen">Listen</a></li>
                <li>
                    <a href="#accpet" aria-label="Accpet">Accpet</a></li>
                <li>
                    <a href="#%e5%94%a4%e9%86%92" aria-label="唤醒">唤醒</a></li>
                <li>
                    <a href="#read" aria-label="Read">Read</a></li>
                <li>
                    <a href="#write" aria-label="Write">Write</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="例子">例子<a hidden class="anchor" aria-hidden="true" href="#例子">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00cd00">func</span> main() {
    lister, err <span style="color:#39c">:=</span> net.Listen(<span style="color:#cd0000">&#34;tcp&#34;</span>, <span style="color:#cd0000">&#34;0.0.0.0:9009&#34;</span>)
    <span style="color:#cdcd00">if</span> err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
        <span style="color:#cdcd00">return</span>
    }
    <span style="color:#cdcd00">for</span> {
        conn, err <span style="color:#39c">:=</span> lister.Accept() <span style="color:#000080">//等待建立连接
</span><span style="color:#000080"></span>        <span style="color:#cdcd00">if</span> err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
            <span style="color:#cdcd00">continue</span>
        }
        <span style="color:#000080">//开启协程处理
</span><span style="color:#000080"></span>        <span style="color:#cdcd00">go</span> <span style="color:#00cd00">func</span>() {
            <span style="color:#cdcd00">defer</span> conn.Close()
            <span style="color:#cdcd00">for</span> {
                buf <span style="color:#39c">:=</span> <span style="color:#cd00cd">make</span>([]<span style="color:#00cd00">byte</span>, <span style="color:#cd00cd">128</span>)
                n, err <span style="color:#39c">:=</span> conn.Read(buf)
                <span style="color:#cdcd00">if</span> err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span>{
                    <span style="color:#cdcd00">return</span>
                }
            }
        }()
    }
}
</code></pre></div><h3 id="listen">Listen<a hidden class="anchor" aria-hidden="true" href="#listen">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00cd00">func</span> Listen(network, address <span style="color:#00cd00">string</span>) (Listener, <span style="color:#00cd00">error</span>) {
	<span style="color:#00cd00">var</span> lc ListenConfig
	<span style="color:#cdcd00">return</span> lc.Listen(context.Background(), network, address)
}

<span style="color:#00cd00">func</span> (lc <span style="color:#39c">*</span>ListenConfig) Listen(ctx context.Context, network, address <span style="color:#00cd00">string</span>) (Listener, <span style="color:#00cd00">error</span>) {
	addrs, err <span style="color:#39c">:=</span> DefaultResolver.resolveAddrList(ctx, <span style="color:#cd0000">&#34;listen&#34;</span>, network, address, <span style="color:#cdcd00">nil</span>)
	<span style="color:#cdcd00">if</span> err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		<span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>, <span style="color:#39c">&amp;</span>OpError{Op: <span style="color:#cd0000">&#34;listen&#34;</span>, Net: network, Source: <span style="color:#cdcd00">nil</span>, Addr: <span style="color:#cdcd00">nil</span>, Err: err}
	}
	sl <span style="color:#39c">:=</span> <span style="color:#39c">&amp;</span>sysListener{
		ListenConfig: <span style="color:#39c">*</span>lc,
		network:      network,
		address:      address,
	}
	<span style="color:#00cd00">var</span> l Listener
	la <span style="color:#39c">:=</span> addrs.first(isIPv4)
	<span style="color:#cdcd00">switch</span> la <span style="color:#39c">:=</span> la.(<span style="color:#00cd00">type</span>) {
	<span style="color:#cdcd00">case</span> <span style="color:#39c">*</span>TCPAddr:
		l, err = sl.listenTCP(ctx, la)
	<span style="color:#cdcd00">case</span> <span style="color:#39c">*</span>UnixAddr:
		l, err = sl.listenUnix(ctx, la)
	<span style="color:#cdcd00">default</span>:
		<span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>, <span style="color:#39c">&amp;</span>OpError{Op: <span style="color:#cd0000">&#34;listen&#34;</span>, Net: sl.network, Source: <span style="color:#cdcd00">nil</span>, Addr: la, Err: <span style="color:#39c">&amp;</span>AddrError{Err: <span style="color:#cd0000">&#34;unexpected address type&#34;</span>, Addr: address}}
	}
	<span style="color:#cdcd00">if</span> err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		<span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>, <span style="color:#39c">&amp;</span>OpError{Op: <span style="color:#cd0000">&#34;listen&#34;</span>, Net: sl.network, Source: <span style="color:#cdcd00">nil</span>, Addr: la, Err: err} <span style="color:#000080">// l is non-nil interface containing nil pointer
</span><span style="color:#000080"></span>	}
	<span style="color:#cdcd00">return</span> l, <span style="color:#cdcd00">nil</span>
}

<span style="color:#00cd00">func</span> (sl <span style="color:#39c">*</span>sysListener) listenTCP(ctx context.Context, laddr <span style="color:#39c">*</span>TCPAddr) (<span style="color:#39c">*</span>TCPListener, <span style="color:#00cd00">error</span>) {
	fd, err <span style="color:#39c">:=</span> internetSocket(ctx, sl.network, laddr, <span style="color:#cdcd00">nil</span>, syscall.SOCK_STREAM, <span style="color:#cd00cd">0</span>, <span style="color:#cd0000">&#34;listen&#34;</span>, sl.ListenConfig.Control)
	<span style="color:#cdcd00">if</span> err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		<span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>, err
	}
	<span style="color:#cdcd00">return</span> <span style="color:#39c">&amp;</span>TCPListener{fd: fd, lc: sl.ListenConfig}, <span style="color:#cdcd00">nil</span>
}

<span style="color:#00cd00">func</span> internetSocket(ctx context.Context, net <span style="color:#00cd00">string</span>, laddr, raddr sockaddr, sotype, proto <span style="color:#00cd00">int</span>, mode <span style="color:#00cd00">string</span>, ctrlFn <span style="color:#00cd00">func</span>(<span style="color:#00cd00">string</span>, <span style="color:#00cd00">string</span>, syscall.RawConn) <span style="color:#00cd00">error</span>) (fd <span style="color:#39c">*</span>netFD, err <span style="color:#00cd00">error</span>) {
	<span style="color:#cdcd00">if</span> (runtime.GOOS <span style="color:#39c">==</span> <span style="color:#cd0000">&#34;aix&#34;</span> <span style="color:#39c">||</span> runtime.GOOS <span style="color:#39c">==</span> <span style="color:#cd0000">&#34;windows&#34;</span> <span style="color:#39c">||</span> runtime.GOOS <span style="color:#39c">==</span> <span style="color:#cd0000">&#34;openbsd&#34;</span>) <span style="color:#39c">&amp;&amp;</span> mode <span style="color:#39c">==</span> <span style="color:#cd0000">&#34;dial&#34;</span> <span style="color:#39c">&amp;&amp;</span> raddr.isWildcard() {
		raddr = raddr.toLocal(net)
	}
	family, ipv6only <span style="color:#39c">:=</span> favoriteAddrFamily(net, laddr, raddr, mode)
	<span style="color:#cdcd00">return</span> socket(ctx, net, family, sotype, proto, ipv6only, laddr, raddr, ctrlFn)
}


<span style="color:#000080">// socket returns a network file descriptor that is ready for
</span><span style="color:#000080">// asynchronous I/O using the network poller.
</span><span style="color:#000080"></span><span style="color:#00cd00">func</span> socket(ctx context.Context, net <span style="color:#00cd00">string</span>, family, sotype, proto <span style="color:#00cd00">int</span>, ipv6only <span style="color:#00cd00">bool</span>, laddr, raddr sockaddr, ctrlFn <span style="color:#00cd00">func</span>(<span style="color:#00cd00">string</span>, <span style="color:#00cd00">string</span>, syscall.RawConn) <span style="color:#00cd00">error</span>) (fd <span style="color:#39c">*</span>netFD, err <span style="color:#00cd00">error</span>) {
	s, err <span style="color:#39c">:=</span> sysSocket(family, sotype, proto)
	<span style="color:#cdcd00">if</span> err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		<span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>, err
	}
	<span style="color:#cdcd00">if</span> err = setDefaultSockopts(s, family, sotype, ipv6only); err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		poll.CloseFunc(s)
		<span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>, err
	}
	<span style="color:#cdcd00">if</span> fd, err = newFD(s, family, sotype, net); err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		poll.CloseFunc(s)
		<span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>, err
	}

	<span style="color:#000080">// This function makes a network file descriptor for the
</span><span style="color:#000080"></span>	<span style="color:#000080">// following applications:
</span><span style="color:#000080"></span>	<span style="color:#000080">//
</span><span style="color:#000080"></span>	<span style="color:#000080">// - An endpoint holder that opens a passive stream
</span><span style="color:#000080"></span>	<span style="color:#000080">//   connection, known as a stream listener
</span><span style="color:#000080"></span>	<span style="color:#000080">//
</span><span style="color:#000080"></span>	<span style="color:#000080">// - An endpoint holder that opens a destination-unspecific
</span><span style="color:#000080"></span>	<span style="color:#000080">//   datagram connection, known as a datagram listener
</span><span style="color:#000080"></span>	<span style="color:#000080">//
</span><span style="color:#000080"></span>	<span style="color:#000080">// - An endpoint holder that opens an active stream or a
</span><span style="color:#000080"></span>	<span style="color:#000080">//   destination-specific datagram connection, known as a
</span><span style="color:#000080"></span>	<span style="color:#000080">//   dialer
</span><span style="color:#000080"></span>	<span style="color:#000080">//
</span><span style="color:#000080"></span>	<span style="color:#000080">// - An endpoint holder that opens the other connection, such
</span><span style="color:#000080"></span>	<span style="color:#000080">//   as talking to the protocol stack inside the kernel
</span><span style="color:#000080"></span>	<span style="color:#000080">//
</span><span style="color:#000080"></span>	<span style="color:#000080">// For stream and datagram listeners, they will only require
</span><span style="color:#000080"></span>	<span style="color:#000080">// named sockets, so we can assume that it&#39;s just a request
</span><span style="color:#000080"></span>	<span style="color:#000080">// from stream or datagram listeners when laddr is not nil but
</span><span style="color:#000080"></span>	<span style="color:#000080">// raddr is nil. Otherwise we assume it&#39;s just for dialers or
</span><span style="color:#000080"></span>	<span style="color:#000080">// the other connection holders.
</span><span style="color:#000080"></span>
	<span style="color:#cdcd00">if</span> laddr <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> <span style="color:#39c">&amp;&amp;</span> raddr <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
		<span style="color:#cdcd00">switch</span> sotype {
		<span style="color:#cdcd00">case</span> syscall.SOCK_STREAM, syscall.SOCK_SEQPACKET:
			<span style="color:#cdcd00">if</span> err <span style="color:#39c">:=</span> fd.listenStream(laddr, listenerBacklog(), ctrlFn); err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
				fd.Close()
				<span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>, err
			}
			<span style="color:#cdcd00">return</span> fd, <span style="color:#cdcd00">nil</span>
		<span style="color:#cdcd00">case</span> syscall.SOCK_DGRAM:
			<span style="color:#cdcd00">if</span> err <span style="color:#39c">:=</span> fd.listenDatagram(laddr, ctrlFn); err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
				fd.Close()
				<span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>, err
			}
			<span style="color:#cdcd00">return</span> fd, <span style="color:#cdcd00">nil</span>
		}
	}
	<span style="color:#cdcd00">if</span> err <span style="color:#39c">:=</span> fd.dial(ctx, laddr, raddr, ctrlFn); err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		fd.Close()
		<span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>, err
	}
	<span style="color:#cdcd00">return</span> fd, <span style="color:#cdcd00">nil</span>
}

<span style="color:#00cd00">func</span> sysSocket(family, sotype, proto <span style="color:#00cd00">int</span>) (<span style="color:#00cd00">int</span>, <span style="color:#00cd00">error</span>) {
	<span style="color:#000080">// See ../syscall/exec_unix.go for description of ForkLock.
</span><span style="color:#000080"></span>	syscall.ForkLock.RLock()
	s, err <span style="color:#39c">:=</span> socketFunc(family, sotype, proto)
	<span style="color:#cdcd00">if</span> err <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
		syscall.CloseOnExec(s)
	}
	syscall.ForkLock.RUnlock()
	<span style="color:#cdcd00">if</span> err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		<span style="color:#cdcd00">return</span> <span style="color:#39c">-</span><span style="color:#cd00cd">1</span>, os.NewSyscallError(<span style="color:#cd0000">&#34;socket&#34;</span>, err)
	}
	<span style="color:#cdcd00">if</span> err = syscall.SetNonblock(s, <span style="color:#cdcd00">true</span>); err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		poll.CloseFunc(s)
		<span style="color:#cdcd00">return</span> <span style="color:#39c">-</span><span style="color:#cd00cd">1</span>, os.NewSyscallError(<span style="color:#cd0000">&#34;setnonblock&#34;</span>, err)
	}
	<span style="color:#cdcd00">return</span> s, <span style="color:#cdcd00">nil</span>
}


<span style="color:#00cd00">func</span> (fd <span style="color:#39c">*</span>netFD) listenStream(laddr sockaddr, backlog <span style="color:#00cd00">int</span>, ctrlFn <span style="color:#00cd00">func</span>(<span style="color:#00cd00">string</span>, <span style="color:#00cd00">string</span>, syscall.RawConn) <span style="color:#00cd00">error</span>) <span style="color:#00cd00">error</span> {
	<span style="color:#00cd00">var</span> err <span style="color:#00cd00">error</span>
	<span style="color:#cdcd00">if</span> err = setDefaultListenerSockopts(fd.pfd.Sysfd); err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		<span style="color:#cdcd00">return</span> err
	}
	<span style="color:#00cd00">var</span> lsa syscall.Sockaddr
	<span style="color:#cdcd00">if</span> lsa, err = laddr.sockaddr(fd.family); err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		<span style="color:#cdcd00">return</span> err
	}
	<span style="color:#cdcd00">if</span> ctrlFn <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		c, err <span style="color:#39c">:=</span> newRawConn(fd)
		<span style="color:#cdcd00">if</span> err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
			<span style="color:#cdcd00">return</span> err
		}
		<span style="color:#cdcd00">if</span> err <span style="color:#39c">:=</span> ctrlFn(fd.ctrlNetwork(), laddr.String(), c); err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
			<span style="color:#cdcd00">return</span> err
		}
	}
	<span style="color:#cdcd00">if</span> err = syscall.Bind(fd.pfd.Sysfd, lsa); err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		<span style="color:#cdcd00">return</span> os.NewSyscallError(<span style="color:#cd0000">&#34;bind&#34;</span>, err)
	}
	<span style="color:#cdcd00">if</span> err = listenFunc(fd.pfd.Sysfd, backlog); err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		<span style="color:#cdcd00">return</span> os.NewSyscallError(<span style="color:#cd0000">&#34;listen&#34;</span>, err)
	}
	<span style="color:#cdcd00">if</span> err = fd.init(); err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		<span style="color:#cdcd00">return</span> err
	}
	lsa, _ = syscall.Getsockname(fd.pfd.Sysfd)
	fd.setAddr(fd.addrFunc()(lsa), <span style="color:#cdcd00">nil</span>)
	<span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>
}

<span style="color:#00cd00">func</span> (fd <span style="color:#39c">*</span>netFD) init() <span style="color:#00cd00">error</span> {
	<span style="color:#cdcd00">return</span> fd.pfd.Init(fd.net, <span style="color:#cdcd00">true</span>)
}

<span style="color:#000080">// Init initializes the FD. The Sysfd field should already be set.
</span><span style="color:#000080">// This can be called multiple times on a single FD.
</span><span style="color:#000080">// The net argument is a network name from the net package (e.g., &#34;tcp&#34;),
</span><span style="color:#000080">// or &#34;file&#34;.
</span><span style="color:#000080">// Set pollable to true if fd should be managed by runtime netpoll.
</span><span style="color:#000080"></span><span style="color:#00cd00">func</span> (fd <span style="color:#39c">*</span>FD) Init(net <span style="color:#00cd00">string</span>, pollable <span style="color:#00cd00">bool</span>) <span style="color:#00cd00">error</span> {
	<span style="color:#000080">// We don&#39;t actually care about the various network types.
</span><span style="color:#000080"></span>	<span style="color:#cdcd00">if</span> net <span style="color:#39c">==</span> <span style="color:#cd0000">&#34;file&#34;</span> {
		fd.isFile = <span style="color:#cdcd00">true</span>
	}
	<span style="color:#cdcd00">if</span> !pollable {
		fd.isBlocking = <span style="color:#cd00cd">1</span>
		<span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>
	}
	err <span style="color:#39c">:=</span> fd.pd.init(fd)
	<span style="color:#cdcd00">if</span> err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		<span style="color:#000080">// If we could not initialize the runtime poller,
</span><span style="color:#000080"></span>		<span style="color:#000080">// assume we are using blocking mode.
</span><span style="color:#000080"></span>		fd.isBlocking = <span style="color:#cd00cd">1</span>
	}
	<span style="color:#cdcd00">return</span> err
}

<span style="color:#00cd00">func</span> (pd <span style="color:#39c">*</span>pollDesc) init(fd <span style="color:#39c">*</span>FD) <span style="color:#00cd00">error</span> {
	serverInit.Do(runtime_pollServerInit)
	ctx, errno <span style="color:#39c">:=</span> runtime_pollOpen(<span style="color:#cd00cd">uintptr</span>(fd.Sysfd))
	<span style="color:#cdcd00">if</span> errno <span style="color:#39c">!=</span> <span style="color:#cd00cd">0</span> {
		<span style="color:#cdcd00">if</span> ctx <span style="color:#39c">!=</span> <span style="color:#cd00cd">0</span> {
			runtime_pollUnblock(ctx)
			runtime_pollClose(ctx)
		}
		<span style="color:#cdcd00">return</span> errnoErr(syscall.Errno(errno))
	}
	pd.runtimeCtx = ctx
	<span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>
}

<span style="color:#00cd00">func</span> runtime_pollServerInit()
<span style="color:#00cd00">func</span> runtime_pollOpen(fd <span style="color:#00cd00">uintptr</span>) (<span style="color:#00cd00">uintptr</span>, <span style="color:#00cd00">int</span>)
<span style="color:#00cd00">func</span> runtime_pollClose(ctx <span style="color:#00cd00">uintptr</span>)
<span style="color:#00cd00">func</span> runtime_pollWait(ctx <span style="color:#00cd00">uintptr</span>, mode <span style="color:#00cd00">int</span>) <span style="color:#00cd00">int</span>
<span style="color:#00cd00">func</span> runtime_pollWaitCanceled(ctx <span style="color:#00cd00">uintptr</span>, mode <span style="color:#00cd00">int</span>) <span style="color:#00cd00">int</span>
<span style="color:#00cd00">func</span> runtime_pollReset(ctx <span style="color:#00cd00">uintptr</span>, mode <span style="color:#00cd00">int</span>) <span style="color:#00cd00">int</span>
<span style="color:#00cd00">func</span> runtime_pollSetDeadline(ctx <span style="color:#00cd00">uintptr</span>, d <span style="color:#00cd00">int64</span>, mode <span style="color:#00cd00">int</span>)
<span style="color:#00cd00">func</span> runtime_pollUnblock(ctx <span style="color:#00cd00">uintptr</span>)
<span style="color:#00cd00">func</span> runtime_isPollServerDescriptor(fd <span style="color:#00cd00">uintptr</span>) <span style="color:#00cd00">bool</span>

<span style="color:#000080">//go:linkname poll_runtime_pollOpen internal/poll.runtime_pollOpen
</span><span style="color:#000080"></span><span style="color:#00cd00">func</span> poll_runtime_pollOpen(fd <span style="color:#00cd00">uintptr</span>) (<span style="color:#39c">*</span>pollDesc, <span style="color:#00cd00">int</span>) {
	pd <span style="color:#39c">:=</span> pollcache.alloc()
	lock(<span style="color:#39c">&amp;</span>pd.lock)
	<span style="color:#cdcd00">if</span> pd.wg <span style="color:#39c">!=</span> <span style="color:#cd00cd">0</span> <span style="color:#39c">&amp;&amp;</span> pd.wg <span style="color:#39c">!=</span> pdReady {
		throw(<span style="color:#cd0000">&#34;runtime: blocked write on free polldesc&#34;</span>)
	}
	<span style="color:#cdcd00">if</span> pd.rg <span style="color:#39c">!=</span> <span style="color:#cd00cd">0</span> <span style="color:#39c">&amp;&amp;</span> pd.rg <span style="color:#39c">!=</span> pdReady {
		throw(<span style="color:#cd0000">&#34;runtime: blocked read on free polldesc&#34;</span>)
	}
	pd.fd = fd
	pd.closing = <span style="color:#cdcd00">false</span>
	pd.everr = <span style="color:#cdcd00">false</span>
	pd.rseq<span style="color:#39c">++</span>
	pd.rg = <span style="color:#cd00cd">0</span>
	pd.rd = <span style="color:#cd00cd">0</span>
	pd.wseq<span style="color:#39c">++</span>
	pd.wg = <span style="color:#cd00cd">0</span>
	pd.wd = <span style="color:#cd00cd">0</span>
	pd.self = pd
	unlock(<span style="color:#39c">&amp;</span>pd.lock)

	<span style="color:#00cd00">var</span> errno <span style="color:#00cd00">int32</span>
	errno = netpollopen(fd, pd)
	<span style="color:#cdcd00">return</span> pd, <span style="color:#cd00cd">int</span>(errno)
}

<span style="color:#00cd00">func</span> netpollopen(fd <span style="color:#00cd00">uintptr</span>, pd <span style="color:#39c">*</span>pollDesc) <span style="color:#00cd00">int32</span> {
	<span style="color:#00cd00">var</span> ev epollevent
	ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET
	<span style="color:#39c">*</span>(<span style="color:#39c">**</span>pollDesc)(unsafe.Pointer(<span style="color:#39c">&amp;</span>ev.data)) = pd
	<span style="color:#cdcd00">return</span> <span style="color:#39c">-</span>epollctl(epfd, _EPOLL_CTL_ADD, <span style="color:#cd00cd">int32</span>(fd), <span style="color:#39c">&amp;</span>ev)
}
</code></pre></div><h3 id="accpet">Accpet<a hidden class="anchor" aria-hidden="true" href="#accpet">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">// Accept implements the Accept method in the Listener interface; it
</span><span style="color:#000080">// waits for the next call and returns a generic Conn.
</span><span style="color:#000080"></span><span style="color:#00cd00">func</span> (l <span style="color:#39c">*</span>TCPListener) Accept() (Conn, <span style="color:#00cd00">error</span>) {
	<span style="color:#cdcd00">if</span> !l.ok() {
		<span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>, syscall.EINVAL
	}
	c, err <span style="color:#39c">:=</span> l.accept()
	<span style="color:#cdcd00">if</span> err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		<span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>, <span style="color:#39c">&amp;</span>OpError{Op: <span style="color:#cd0000">&#34;accept&#34;</span>, Net: l.fd.net, Source: <span style="color:#cdcd00">nil</span>, Addr: l.fd.laddr, Err: err}
	}
	<span style="color:#cdcd00">return</span> c, <span style="color:#cdcd00">nil</span>
}

<span style="color:#00cd00">func</span> (ln <span style="color:#39c">*</span>TCPListener) accept() (<span style="color:#39c">*</span>TCPConn, <span style="color:#00cd00">error</span>) {
	fd, err <span style="color:#39c">:=</span> ln.fd.accept()
	<span style="color:#cdcd00">if</span> err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		<span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>, err
	}
	tc <span style="color:#39c">:=</span> newTCPConn(fd)
	<span style="color:#cdcd00">if</span> ln.lc.KeepAlive <span style="color:#39c">&gt;=</span> <span style="color:#cd00cd">0</span> {
		setKeepAlive(fd, <span style="color:#cdcd00">true</span>)
		ka <span style="color:#39c">:=</span> ln.lc.KeepAlive
		<span style="color:#cdcd00">if</span> ln.lc.KeepAlive <span style="color:#39c">==</span> <span style="color:#cd00cd">0</span> {
			ka = defaultTCPKeepAlive
		}
		setKeepAlivePeriod(fd, ka)
	}
	<span style="color:#cdcd00">return</span> tc, <span style="color:#cdcd00">nil</span>
}

<span style="color:#00cd00">func</span> (fd <span style="color:#39c">*</span>netFD) accept() (netfd <span style="color:#39c">*</span>netFD, err <span style="color:#00cd00">error</span>) {
	d, rsa, errcall, err <span style="color:#39c">:=</span> fd.pfd.Accept()
	<span style="color:#cdcd00">if</span> err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		<span style="color:#cdcd00">if</span> errcall <span style="color:#39c">!=</span> <span style="color:#cd0000">&#34;&#34;</span> {
			err = wrapSyscallError(errcall, err)
		}
		<span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>, err
	}

	<span style="color:#cdcd00">if</span> netfd, err = newFD(d, fd.family, fd.sotype, fd.net); err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		poll.CloseFunc(d)
		<span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>, err
	}
	<span style="color:#cdcd00">if</span> err = netfd.init(); err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		netfd.Close()
		<span style="color:#cdcd00">return</span> <span style="color:#cdcd00">nil</span>, err
	}
	lsa, _ <span style="color:#39c">:=</span> syscall.Getsockname(netfd.pfd.Sysfd)
	netfd.setAddr(netfd.addrFunc()(lsa), netfd.addrFunc()(rsa))
	<span style="color:#cdcd00">return</span> netfd, <span style="color:#cdcd00">nil</span>
}


<span style="color:#000080">// Accept wraps the accept network call.
</span><span style="color:#000080"></span><span style="color:#00cd00">func</span> (fd <span style="color:#39c">*</span>FD) Accept() (<span style="color:#00cd00">int</span>, syscall.Sockaddr, <span style="color:#00cd00">string</span>, <span style="color:#00cd00">error</span>) {
	<span style="color:#cdcd00">if</span> err <span style="color:#39c">:=</span> fd.readLock(); err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		<span style="color:#cdcd00">return</span> <span style="color:#39c">-</span><span style="color:#cd00cd">1</span>, <span style="color:#cdcd00">nil</span>, <span style="color:#cd0000">&#34;&#34;</span>, err
	}
	<span style="color:#cdcd00">defer</span> fd.readUnlock()

	<span style="color:#cdcd00">if</span> err <span style="color:#39c">:=</span> fd.pd.prepareRead(fd.isFile); err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		<span style="color:#cdcd00">return</span> <span style="color:#39c">-</span><span style="color:#cd00cd">1</span>, <span style="color:#cdcd00">nil</span>, <span style="color:#cd0000">&#34;&#34;</span>, err
	}
	<span style="color:#cdcd00">for</span> {
		s, rsa, errcall, err <span style="color:#39c">:=</span> accept(fd.Sysfd)
		<span style="color:#cdcd00">if</span> err <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
			<span style="color:#cdcd00">return</span> s, rsa, <span style="color:#cd0000">&#34;&#34;</span>, err
		}
		<span style="color:#cdcd00">switch</span> err {
		<span style="color:#cdcd00">case</span> syscall.EINTR:
			<span style="color:#cdcd00">continue</span>
		<span style="color:#cdcd00">case</span> syscall.EAGAIN:
			<span style="color:#cdcd00">if</span> fd.pd.pollable() {
				<span style="color:#cdcd00">if</span> err = fd.pd.waitRead(fd.isFile); err <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
					<span style="color:#cdcd00">continue</span>
				}
			}
		<span style="color:#cdcd00">case</span> syscall.ECONNABORTED:
			<span style="color:#000080">// This means that a socket on the listen
</span><span style="color:#000080"></span>			<span style="color:#000080">// queue was closed before we Accept()ed it;
</span><span style="color:#000080"></span>			<span style="color:#000080">// it&#39;s a silly error, so try again.
</span><span style="color:#000080"></span>			<span style="color:#cdcd00">continue</span>
		}
		<span style="color:#cdcd00">return</span> <span style="color:#39c">-</span><span style="color:#cd00cd">1</span>, <span style="color:#cdcd00">nil</span>, errcall, err
	}
}

<span style="color:#00cd00">func</span> (pd <span style="color:#39c">*</span>pollDesc) pollable() <span style="color:#00cd00">bool</span> {
	<span style="color:#cdcd00">return</span> pd.runtimeCtx <span style="color:#39c">!=</span> <span style="color:#cd00cd">0</span>
}

<span style="color:#00cd00">func</span> (pd <span style="color:#39c">*</span>pollDesc) waitRead(isFile <span style="color:#00cd00">bool</span>) <span style="color:#00cd00">error</span> {
	<span style="color:#cdcd00">return</span> pd.wait(<span style="color:#cd0000">&#39;r&#39;</span>, isFile)
}

<span style="color:#00cd00">func</span> (pd <span style="color:#39c">*</span>pollDesc) wait(mode <span style="color:#00cd00">int</span>, isFile <span style="color:#00cd00">bool</span>) <span style="color:#00cd00">error</span> {
	<span style="color:#cdcd00">if</span> pd.runtimeCtx <span style="color:#39c">==</span> <span style="color:#cd00cd">0</span> {
		<span style="color:#cdcd00">return</span> errors.New(<span style="color:#cd0000">&#34;waiting for unsupported file type&#34;</span>)
	}
	res <span style="color:#39c">:=</span> runtime_pollWait(pd.runtimeCtx, mode)
	<span style="color:#cdcd00">return</span> convertErr(res, isFile)
}

<span style="color:#00cd00">func</span> poll_runtime_pollWait(pd <span style="color:#39c">*</span>pollDesc, mode <span style="color:#00cd00">int</span>) <span style="color:#00cd00">int</span> {
	errcode <span style="color:#39c">:=</span> netpollcheckerr(pd, <span style="color:#cd00cd">int32</span>(mode))
	<span style="color:#cdcd00">if</span> errcode <span style="color:#39c">!=</span> pollNoError {
		<span style="color:#cdcd00">return</span> errcode
	}
	<span style="color:#000080">// As for now only Solaris, illumos, and AIX use level-triggered IO.
</span><span style="color:#000080"></span>	<span style="color:#cdcd00">if</span> GOOS <span style="color:#39c">==</span> <span style="color:#cd0000">&#34;solaris&#34;</span> <span style="color:#39c">||</span> GOOS <span style="color:#39c">==</span> <span style="color:#cd0000">&#34;illumos&#34;</span> <span style="color:#39c">||</span> GOOS <span style="color:#39c">==</span> <span style="color:#cd0000">&#34;aix&#34;</span> {
		netpollarm(pd, mode)
	}
	<span style="color:#cdcd00">for</span> !netpollblock(pd, <span style="color:#cd00cd">int32</span>(mode), <span style="color:#cdcd00">false</span>) {
		errcode = netpollcheckerr(pd, <span style="color:#cd00cd">int32</span>(mode))
		<span style="color:#cdcd00">if</span> errcode <span style="color:#39c">!=</span> pollNoError {
			<span style="color:#cdcd00">return</span> errcode
		}
		<span style="color:#000080">// Can happen if timeout has fired and unblocked us,
</span><span style="color:#000080"></span>		<span style="color:#000080">// but before we had a chance to run, timeout has been reset.
</span><span style="color:#000080"></span>		<span style="color:#000080">// Pretend it has not happened and retry.
</span><span style="color:#000080"></span>	}
	<span style="color:#cdcd00">return</span> pollNoError
}

<span style="color:#000080">// returns true if IO is ready, or false if timedout or closed
</span><span style="color:#000080">// waitio - wait only for completed IO, ignore errors
</span><span style="color:#000080"></span><span style="color:#00cd00">func</span> netpollblock(pd <span style="color:#39c">*</span>pollDesc, mode <span style="color:#00cd00">int32</span>, waitio <span style="color:#00cd00">bool</span>) <span style="color:#00cd00">bool</span> {
	gpp <span style="color:#39c">:=</span> <span style="color:#39c">&amp;</span>pd.rg
	<span style="color:#cdcd00">if</span> mode <span style="color:#39c">==</span> <span style="color:#cd0000">&#39;w&#39;</span> {
		gpp = <span style="color:#39c">&amp;</span>pd.wg
	}

	<span style="color:#000080">// set the gpp semaphore to pdWait
</span><span style="color:#000080"></span>	<span style="color:#cdcd00">for</span> {
		old <span style="color:#39c">:=</span> <span style="color:#39c">*</span>gpp
		<span style="color:#cdcd00">if</span> old <span style="color:#39c">==</span> pdReady {
			<span style="color:#39c">*</span>gpp = <span style="color:#cd00cd">0</span>
			<span style="color:#cdcd00">return</span> <span style="color:#cdcd00">true</span>
		}
		<span style="color:#cdcd00">if</span> old <span style="color:#39c">!=</span> <span style="color:#cd00cd">0</span> {
			throw(<span style="color:#cd0000">&#34;runtime: double wait&#34;</span>)
		}
		<span style="color:#cdcd00">if</span> atomic.Casuintptr(gpp, <span style="color:#cd00cd">0</span>, pdWait) {
			<span style="color:#cdcd00">break</span>
		}
	}

	<span style="color:#000080">// need to recheck error states after setting gpp to pdWait
</span><span style="color:#000080"></span>	<span style="color:#000080">// this is necessary because runtime_pollUnblock/runtime_pollSetDeadline/deadlineimpl
</span><span style="color:#000080"></span>	<span style="color:#000080">// do the opposite: store to closing/rd/wd, membarrier, load of rg/wg
</span><span style="color:#000080"></span>	<span style="color:#cdcd00">if</span> waitio <span style="color:#39c">||</span> netpollcheckerr(pd, mode) <span style="color:#39c">==</span> <span style="color:#cd00cd">0</span> {
		gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, <span style="color:#cd00cd">5</span>)
	}
	<span style="color:#000080">// be careful to not lose concurrent pdReady notification
</span><span style="color:#000080"></span>	old <span style="color:#39c">:=</span> atomic.Xchguintptr(gpp, <span style="color:#cd00cd">0</span>)
	<span style="color:#cdcd00">if</span> old &gt; pdWait {
		throw(<span style="color:#cd0000">&#34;runtime: corrupted polldesc&#34;</span>)
	}
	<span style="color:#cdcd00">return</span> old <span style="color:#39c">==</span> pdReady
}

<span style="color:#000080">// Puts the current goroutine into a waiting state and calls unlockf on the
</span><span style="color:#000080">// system stack.
</span><span style="color:#000080">//
</span><span style="color:#000080">// If unlockf returns false, the goroutine is resumed.
</span><span style="color:#000080">//
</span><span style="color:#000080">// unlockf must not access this G&#39;s stack, as it may be moved between
</span><span style="color:#000080">// the call to gopark and the call to unlockf.
</span><span style="color:#000080">//
</span><span style="color:#000080">// Note that because unlockf is called after putting the G into a waiting
</span><span style="color:#000080">// state, the G may have already been readied by the time unlockf is called
</span><span style="color:#000080">// unless there is external synchronization preventing the G from being
</span><span style="color:#000080">// readied. If unlockf returns false, it must guarantee that the G cannot be
</span><span style="color:#000080">// externally readied.
</span><span style="color:#000080">//
</span><span style="color:#000080">// Reason explains why the goroutine has been parked. It is displayed in stack
</span><span style="color:#000080">// traces and heap dumps. Reasons should be unique and descriptive. Do not
</span><span style="color:#000080">// re-use reasons, add new ones.
</span><span style="color:#000080"></span><span style="color:#00cd00">func</span> gopark(unlockf <span style="color:#00cd00">func</span>(<span style="color:#39c">*</span>g, unsafe.Pointer) <span style="color:#00cd00">bool</span>, lock unsafe.Pointer, reason waitReason, traceEv <span style="color:#00cd00">byte</span>, traceskip <span style="color:#00cd00">int</span>) {
	<span style="color:#cdcd00">if</span> reason <span style="color:#39c">!=</span> waitReasonSleep {
		checkTimeouts() <span style="color:#000080">// timeouts may expire while two goroutines keep the scheduler busy
</span><span style="color:#000080"></span>	}
	mp <span style="color:#39c">:=</span> acquirem()
	gp <span style="color:#39c">:=</span> mp.curg
	status <span style="color:#39c">:=</span> readgstatus(gp)
	<span style="color:#cdcd00">if</span> status <span style="color:#39c">!=</span> _Grunning <span style="color:#39c">&amp;&amp;</span> status <span style="color:#39c">!=</span> _Gscanrunning {
		throw(<span style="color:#cd0000">&#34;gopark: bad g status&#34;</span>)
	}
	mp.waitlock = lock
	mp.waitunlockf = unlockf
	gp.waitreason = reason
	mp.waittraceev = traceEv
	mp.waittraceskip = traceskip
	releasem(mp)
	<span style="color:#000080">// can&#39;t do anything that might move the G between Ms here.
</span><span style="color:#000080"></span>	mcall(park_m)
}
</code></pre></div><h3 id="唤醒">唤醒<a hidden class="anchor" aria-hidden="true" href="#唤醒">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00cd00">func</span> sysmon() {
	lock(<span style="color:#39c">&amp;</span>sched.lock)
	sched.nmsys<span style="color:#39c">++</span>
	checkdead()
	unlock(<span style="color:#39c">&amp;</span>sched.lock)

	<span style="color:#000080">// For syscall_runtime_doAllThreadsSyscall, sysmon is
</span><span style="color:#000080"></span>	<span style="color:#000080">// sufficiently up to participate in fixups.
</span><span style="color:#000080"></span>	atomic.Store(<span style="color:#39c">&amp;</span>sched.sysmonStarting, <span style="color:#cd00cd">0</span>)

	lasttrace <span style="color:#39c">:=</span> <span style="color:#cd00cd">int64</span>(<span style="color:#cd00cd">0</span>)
	idle <span style="color:#39c">:=</span> <span style="color:#cd00cd">0</span> <span style="color:#000080">// how many cycles in succession we had not wokeup somebody
</span><span style="color:#000080"></span>	delay <span style="color:#39c">:=</span> <span style="color:#cd00cd">uint32</span>(<span style="color:#cd00cd">0</span>)

	<span style="color:#cdcd00">for</span> {
		<span style="color:#cdcd00">if</span> idle <span style="color:#39c">==</span> <span style="color:#cd00cd">0</span> { <span style="color:#000080">// start with 20us sleep...
</span><span style="color:#000080"></span>			delay = <span style="color:#cd00cd">20</span>
		} <span style="color:#cdcd00">else</span> <span style="color:#cdcd00">if</span> idle &gt; <span style="color:#cd00cd">50</span> { <span style="color:#000080">// start doubling the sleep after 1ms...
</span><span style="color:#000080"></span>			delay <span style="color:#39c">*=</span> <span style="color:#cd00cd">2</span>
		}
		<span style="color:#cdcd00">if</span> delay &gt; <span style="color:#cd00cd">10</span><span style="color:#39c">*</span><span style="color:#cd00cd">1000</span> { <span style="color:#000080">// up to 10ms
</span><span style="color:#000080"></span>			delay = <span style="color:#cd00cd">10</span> <span style="color:#39c">*</span> <span style="color:#cd00cd">1000</span>
		}
		usleep(delay)
		mDoFixup()

		<span style="color:#000080">// sysmon should not enter deep sleep if schedtrace is enabled so that
</span><span style="color:#000080"></span>		<span style="color:#000080">// it can print that information at the right time.
</span><span style="color:#000080"></span>		<span style="color:#000080">//
</span><span style="color:#000080"></span>		<span style="color:#000080">// It should also not enter deep sleep if there are any active P&#39;s so
</span><span style="color:#000080"></span>		<span style="color:#000080">// that it can retake P&#39;s from syscalls, preempt long running G&#39;s, and
</span><span style="color:#000080"></span>		<span style="color:#000080">// poll the network if all P&#39;s are busy for long stretches.
</span><span style="color:#000080"></span>		<span style="color:#000080">//
</span><span style="color:#000080"></span>		<span style="color:#000080">// It should wakeup from deep sleep if any P&#39;s become active either due
</span><span style="color:#000080"></span>		<span style="color:#000080">// to exiting a syscall or waking up due to a timer expiring so that it
</span><span style="color:#000080"></span>		<span style="color:#000080">// can resume performing those duties. If it wakes from a syscall it
</span><span style="color:#000080"></span>		<span style="color:#000080">// resets idle and delay as a bet that since it had retaken a P from a
</span><span style="color:#000080"></span>		<span style="color:#000080">// syscall before, it may need to do it again shortly after the
</span><span style="color:#000080"></span>		<span style="color:#000080">// application starts work again. It does not reset idle when waking
</span><span style="color:#000080"></span>		<span style="color:#000080">// from a timer to avoid adding system load to applications that spend
</span><span style="color:#000080"></span>		<span style="color:#000080">// most of their time sleeping.
</span><span style="color:#000080"></span>		now <span style="color:#39c">:=</span> nanotime()
		<span style="color:#cdcd00">if</span> debug.schedtrace <span style="color:#39c">&lt;=</span> <span style="color:#cd00cd">0</span> <span style="color:#39c">&amp;&amp;</span> (sched.gcwaiting <span style="color:#39c">!=</span> <span style="color:#cd00cd">0</span> <span style="color:#39c">||</span> atomic.Load(<span style="color:#39c">&amp;</span>sched.npidle) <span style="color:#39c">==</span> <span style="color:#cd00cd">uint32</span>(gomaxprocs)) {
			lock(<span style="color:#39c">&amp;</span>sched.lock)
			<span style="color:#cdcd00">if</span> atomic.Load(<span style="color:#39c">&amp;</span>sched.gcwaiting) <span style="color:#39c">!=</span> <span style="color:#cd00cd">0</span> <span style="color:#39c">||</span> atomic.Load(<span style="color:#39c">&amp;</span>sched.npidle) <span style="color:#39c">==</span> <span style="color:#cd00cd">uint32</span>(gomaxprocs) {
				syscallWake <span style="color:#39c">:=</span> <span style="color:#cdcd00">false</span>
				next, _ <span style="color:#39c">:=</span> timeSleepUntil()
				<span style="color:#cdcd00">if</span> next &gt; now {
					atomic.Store(<span style="color:#39c">&amp;</span>sched.sysmonwait, <span style="color:#cd00cd">1</span>)
					unlock(<span style="color:#39c">&amp;</span>sched.lock)
					<span style="color:#000080">// Make wake-up period small enough
</span><span style="color:#000080"></span>					<span style="color:#000080">// for the sampling to be correct.
</span><span style="color:#000080"></span>					sleep <span style="color:#39c">:=</span> forcegcperiod <span style="color:#39c">/</span> <span style="color:#cd00cd">2</span>
					<span style="color:#cdcd00">if</span> next<span style="color:#39c">-</span>now &lt; sleep {
						sleep = next <span style="color:#39c">-</span> now
					}
					shouldRelax <span style="color:#39c">:=</span> sleep <span style="color:#39c">&gt;=</span> osRelaxMinNS
					<span style="color:#cdcd00">if</span> shouldRelax {
						osRelax(<span style="color:#cdcd00">true</span>)
					}
					syscallWake = notetsleep(<span style="color:#39c">&amp;</span>sched.sysmonnote, sleep)
					mDoFixup()
					<span style="color:#cdcd00">if</span> shouldRelax {
						osRelax(<span style="color:#cdcd00">false</span>)
					}
					lock(<span style="color:#39c">&amp;</span>sched.lock)
					atomic.Store(<span style="color:#39c">&amp;</span>sched.sysmonwait, <span style="color:#cd00cd">0</span>)
					noteclear(<span style="color:#39c">&amp;</span>sched.sysmonnote)
				}
				<span style="color:#cdcd00">if</span> syscallWake {
					idle = <span style="color:#cd00cd">0</span>
					delay = <span style="color:#cd00cd">20</span>
				}
			}
			unlock(<span style="color:#39c">&amp;</span>sched.lock)
		}

		lock(<span style="color:#39c">&amp;</span>sched.sysmonlock)
		<span style="color:#000080">// Update now in case we blocked on sysmonnote or spent a long time
</span><span style="color:#000080"></span>		<span style="color:#000080">// blocked on schedlock or sysmonlock above.
</span><span style="color:#000080"></span>		now = nanotime()

		<span style="color:#000080">// trigger libc interceptors if needed
</span><span style="color:#000080"></span>		<span style="color:#cdcd00">if</span> <span style="color:#39c">*</span>cgo_yield <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
			asmcgocall(<span style="color:#39c">*</span>cgo_yield, <span style="color:#cdcd00">nil</span>)
		}
		<span style="color:#000080">// poll network if not polled for more than 10ms
</span><span style="color:#000080"></span>		lastpoll <span style="color:#39c">:=</span> <span style="color:#cd00cd">int64</span>(atomic.Load64(<span style="color:#39c">&amp;</span>sched.lastpoll))
		<span style="color:#cdcd00">if</span> netpollinited() <span style="color:#39c">&amp;&amp;</span> lastpoll <span style="color:#39c">!=</span> <span style="color:#cd00cd">0</span> <span style="color:#39c">&amp;&amp;</span> lastpoll<span style="color:#39c">+</span><span style="color:#cd00cd">10</span><span style="color:#39c">*</span><span style="color:#cd00cd">1000</span><span style="color:#39c">*</span><span style="color:#cd00cd">1000</span> &lt; now {
			atomic.Cas64(<span style="color:#39c">&amp;</span>sched.lastpoll, <span style="color:#cd00cd">uint64</span>(lastpoll), <span style="color:#cd00cd">uint64</span>(now))
			list <span style="color:#39c">:=</span> netpoll(<span style="color:#cd00cd">0</span>) <span style="color:#000080">// non-blocking - returns list of goroutines
</span><span style="color:#000080"></span>			<span style="color:#cdcd00">if</span> !list.empty() {
				<span style="color:#000080">// Need to decrement number of idle locked M&#39;s
</span><span style="color:#000080"></span>				<span style="color:#000080">// (pretending that one more is running) before injectglist.
</span><span style="color:#000080"></span>				<span style="color:#000080">// Otherwise it can lead to the following situation:
</span><span style="color:#000080"></span>				<span style="color:#000080">// injectglist grabs all P&#39;s but before it starts M&#39;s to run the P&#39;s,
</span><span style="color:#000080"></span>				<span style="color:#000080">// another M returns from syscall, finishes running its G,
</span><span style="color:#000080"></span>				<span style="color:#000080">// observes that there is no work to do and no other running M&#39;s
</span><span style="color:#000080"></span>				<span style="color:#000080">// and reports deadlock.
</span><span style="color:#000080"></span>				incidlelocked(<span style="color:#39c">-</span><span style="color:#cd00cd">1</span>)
				injectglist(<span style="color:#39c">&amp;</span>list)
				incidlelocked(<span style="color:#cd00cd">1</span>)
			}
		}
		mDoFixup()
		<span style="color:#cdcd00">if</span> GOOS <span style="color:#39c">==</span> <span style="color:#cd0000">&#34;netbsd&#34;</span> {
			<span style="color:#000080">// netpoll is responsible for waiting for timer
</span><span style="color:#000080"></span>			<span style="color:#000080">// expiration, so we typically don&#39;t have to worry
</span><span style="color:#000080"></span>			<span style="color:#000080">// about starting an M to service timers. (Note that
</span><span style="color:#000080"></span>			<span style="color:#000080">// sleep for timeSleepUntil above simply ensures sysmon
</span><span style="color:#000080"></span>			<span style="color:#000080">// starts running again when that timer expiration may
</span><span style="color:#000080"></span>			<span style="color:#000080">// cause Go code to run again).
</span><span style="color:#000080"></span>			<span style="color:#000080">//
</span><span style="color:#000080"></span>			<span style="color:#000080">// However, netbsd has a kernel bug that sometimes
</span><span style="color:#000080"></span>			<span style="color:#000080">// misses netpollBreak wake-ups, which can lead to
</span><span style="color:#000080"></span>			<span style="color:#000080">// unbounded delays servicing timers. If we detect this
</span><span style="color:#000080"></span>			<span style="color:#000080">// overrun, then startm to get something to handle the
</span><span style="color:#000080"></span>			<span style="color:#000080">// timer.
</span><span style="color:#000080"></span>			<span style="color:#000080">//
</span><span style="color:#000080"></span>			<span style="color:#000080">// See issue 42515 and
</span><span style="color:#000080"></span>			<span style="color:#000080">// https://gnats.netbsd.org/cgi-bin/query-pr-single.pl?number=50094.
</span><span style="color:#000080"></span>			<span style="color:#cdcd00">if</span> next, _ <span style="color:#39c">:=</span> timeSleepUntil(); next &lt; now {
				startm(<span style="color:#cdcd00">nil</span>, <span style="color:#cdcd00">false</span>)
			}
		}
		<span style="color:#cdcd00">if</span> atomic.Load(<span style="color:#39c">&amp;</span>scavenge.sysmonWake) <span style="color:#39c">!=</span> <span style="color:#cd00cd">0</span> {
			<span style="color:#000080">// Kick the scavenger awake if someone requested it.
</span><span style="color:#000080"></span>			wakeScavenger()
		}
		<span style="color:#000080">// retake P&#39;s blocked in syscalls
</span><span style="color:#000080"></span>		<span style="color:#000080">// and preempt long running G&#39;s
</span><span style="color:#000080"></span>		<span style="color:#cdcd00">if</span> retake(now) <span style="color:#39c">!=</span> <span style="color:#cd00cd">0</span> {
			idle = <span style="color:#cd00cd">0</span>
		} <span style="color:#cdcd00">else</span> {
			idle<span style="color:#39c">++</span>
		}
		<span style="color:#000080">// check if we need to force a GC
</span><span style="color:#000080"></span>		<span style="color:#cdcd00">if</span> t <span style="color:#39c">:=</span> (gcTrigger{kind: gcTriggerTime, now: now}); t.test() <span style="color:#39c">&amp;&amp;</span> atomic.Load(<span style="color:#39c">&amp;</span>forcegc.idle) <span style="color:#39c">!=</span> <span style="color:#cd00cd">0</span> {
			lock(<span style="color:#39c">&amp;</span>forcegc.lock)
			forcegc.idle = <span style="color:#cd00cd">0</span>
			<span style="color:#00cd00">var</span> list gList
			list.push(forcegc.g)
			injectglist(<span style="color:#39c">&amp;</span>list)
			unlock(<span style="color:#39c">&amp;</span>forcegc.lock)
		}
		<span style="color:#cdcd00">if</span> debug.schedtrace &gt; <span style="color:#cd00cd">0</span> <span style="color:#39c">&amp;&amp;</span> lasttrace<span style="color:#39c">+</span><span style="color:#cd00cd">int64</span>(debug.schedtrace)<span style="color:#39c">*</span><span style="color:#cd00cd">1000000</span> <span style="color:#39c">&lt;=</span> now {
			lasttrace = now
			schedtrace(debug.scheddetail &gt; <span style="color:#cd00cd">0</span>)
		}
		unlock(<span style="color:#39c">&amp;</span>sched.sysmonlock)
	}
}
</code></pre></div><h3 id="read">Read<a hidden class="anchor" aria-hidden="true" href="#read">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">// Read implements io.Reader.
</span><span style="color:#000080"></span><span style="color:#00cd00">func</span> (fd <span style="color:#39c">*</span>FD) Read(p []<span style="color:#00cd00">byte</span>) (<span style="color:#00cd00">int</span>, <span style="color:#00cd00">error</span>) {
	<span style="color:#cdcd00">if</span> err <span style="color:#39c">:=</span> fd.readLock(); err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		<span style="color:#cdcd00">return</span> <span style="color:#cd00cd">0</span>, err
	}
	<span style="color:#cdcd00">defer</span> fd.readUnlock()
	<span style="color:#cdcd00">if</span> <span style="color:#cd00cd">len</span>(p) <span style="color:#39c">==</span> <span style="color:#cd00cd">0</span> {
		<span style="color:#000080">// If the caller wanted a zero byte read, return immediately
</span><span style="color:#000080"></span>		<span style="color:#000080">// without trying (but after acquiring the readLock).
</span><span style="color:#000080"></span>		<span style="color:#000080">// Otherwise syscall.Read returns 0, nil which looks like
</span><span style="color:#000080"></span>		<span style="color:#000080">// io.EOF.
</span><span style="color:#000080"></span>		<span style="color:#000080">// TODO(bradfitz): make it wait for readability? (Issue 15735)
</span><span style="color:#000080"></span>		<span style="color:#cdcd00">return</span> <span style="color:#cd00cd">0</span>, <span style="color:#cdcd00">nil</span>
	}
	<span style="color:#cdcd00">if</span> err <span style="color:#39c">:=</span> fd.pd.prepareRead(fd.isFile); err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		<span style="color:#cdcd00">return</span> <span style="color:#cd00cd">0</span>, err
	}
	<span style="color:#cdcd00">if</span> fd.IsStream <span style="color:#39c">&amp;&amp;</span> <span style="color:#cd00cd">len</span>(p) &gt; maxRW {
		p = p[:maxRW]
	}
	<span style="color:#cdcd00">for</span> {
		n, err <span style="color:#39c">:=</span> ignoringEINTRIO(syscall.Read, fd.Sysfd, p)
		<span style="color:#cdcd00">if</span> err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
			n = <span style="color:#cd00cd">0</span>
			<span style="color:#cdcd00">if</span> err <span style="color:#39c">==</span> syscall.EAGAIN <span style="color:#39c">&amp;&amp;</span> fd.pd.pollable() {
				<span style="color:#cdcd00">if</span> err = fd.pd.waitRead(fd.isFile); err <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
					<span style="color:#cdcd00">continue</span>
				}
			}
		}
		err = fd.eofError(n, err)
		<span style="color:#cdcd00">return</span> n, err
	}
}
</code></pre></div><h3 id="write">Write<a hidden class="anchor" aria-hidden="true" href="#write">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">// Write implements io.Writer.
</span><span style="color:#000080"></span><span style="color:#00cd00">func</span> (fd <span style="color:#39c">*</span>FD) Write(p []<span style="color:#00cd00">byte</span>) (<span style="color:#00cd00">int</span>, <span style="color:#00cd00">error</span>) {
	<span style="color:#cdcd00">if</span> err <span style="color:#39c">:=</span> fd.writeLock(); err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		<span style="color:#cdcd00">return</span> <span style="color:#cd00cd">0</span>, err
	}
	<span style="color:#cdcd00">defer</span> fd.writeUnlock()
	<span style="color:#cdcd00">if</span> err <span style="color:#39c">:=</span> fd.pd.prepareWrite(fd.isFile); err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
		<span style="color:#cdcd00">return</span> <span style="color:#cd00cd">0</span>, err
	}
	<span style="color:#00cd00">var</span> nn <span style="color:#00cd00">int</span>
	<span style="color:#cdcd00">for</span> {
		max <span style="color:#39c">:=</span> <span style="color:#cd00cd">len</span>(p)
		<span style="color:#cdcd00">if</span> fd.IsStream <span style="color:#39c">&amp;&amp;</span> max<span style="color:#39c">-</span>nn &gt; maxRW {
			max = nn <span style="color:#39c">+</span> maxRW
		}
		n, err <span style="color:#39c">:=</span> ignoringEINTRIO(syscall.Write, fd.Sysfd, p[nn:max])
		<span style="color:#cdcd00">if</span> n &gt; <span style="color:#cd00cd">0</span> {
			nn <span style="color:#39c">+=</span> n
		}
		<span style="color:#cdcd00">if</span> nn <span style="color:#39c">==</span> <span style="color:#cd00cd">len</span>(p) {
			<span style="color:#cdcd00">return</span> nn, err
		}
		<span style="color:#cdcd00">if</span> err <span style="color:#39c">==</span> syscall.EAGAIN <span style="color:#39c">&amp;&amp;</span> fd.pd.pollable() {
			<span style="color:#cdcd00">if</span> err = fd.pd.waitWrite(fd.isFile); err <span style="color:#39c">==</span> <span style="color:#cdcd00">nil</span> {
				<span style="color:#cdcd00">continue</span>
			}
		}
		<span style="color:#cdcd00">if</span> err <span style="color:#39c">!=</span> <span style="color:#cdcd00">nil</span> {
			<span style="color:#cdcd00">return</span> nn, err
		}
		<span style="color:#cdcd00">if</span> n <span style="color:#39c">==</span> <span style="color:#cd00cd">0</span> {
			<span style="color:#cdcd00">return</span> nn, io.ErrUnexpectedEOF
		}
	}
}
</code></pre></div><blockquote>
<p>/go/src/runtime/netpoll.go</p>
</blockquote>
<p>定义了几个抽象方法</p>
<div class="highlight"><pre tabindex="0" style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#000080">// Initialize the poller. Only called once.
</span><span style="color:#000080"></span><span style="color:#00cd00">func</span> netpollinit()

<span style="color:#000080">// Arm edge-triggered notifications for fd. The pd argument is to pass
</span><span style="color:#000080">// back to netpollready when fd is ready. Return an errno value.
</span><span style="color:#000080"></span><span style="color:#00cd00">func</span> netpollopen(fd <span style="color:#00cd00">uintptr</span>, pd <span style="color:#39c">*</span>pollDesc) <span style="color:#00cd00">int32</span>

<span style="color:#000080">// Poll the network. If delta &lt; 0, block indefinitely. If delta == 0,
</span><span style="color:#000080">// poll without blocking. If delta &gt; 0, block for up to delta nanoseconds.
</span><span style="color:#000080">// Return a list of goroutines built by calling netpollready.
</span><span style="color:#000080"></span><span style="color:#00cd00">func</span> netpoll(delta <span style="color:#00cd00">int64</span>) gList

<span style="color:#000080">// Wake up the network poller, assumed to be blocked in netpoll.
</span><span style="color:#000080"></span><span style="color:#00cd00">func</span> netpollBreak()

<span style="color:#000080">// Reports whether fd is a file descriptor used by the poller.
</span><span style="color:#000080"></span><span style="color:#00cd00">func</span> netpollIsPollDescriptor(fd <span style="color:#00cd00">uintptr</span>) <span style="color:#00cd00">bool</span>
</code></pre></div><p>分平台实现</p>
<ul>
<li>netpoll.go</li>
<li>netpoll_aix.go</li>
<li>netpoll_epoll.go</li>
<li>netpoll_fake.go</li>
<li>netpoll_kqueue.go</li>
<li>netpoll_os_test.go</li>
<li>netpoll_solaris.go</li>
<li>netpoll_stub.go</li>
<li>netpoll_windows.go</li>
</ul>
<p>看linux怎么做的</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lambertxiao.github.io/tags/golang/">golang</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://lambertxiao.github.io/posts/leveldb-bloomfilter/doc/">
    <span class="title">« Prev Page</span>
    <br>
    <span>LevelDB是干嘛的</span>
  </a>
  <a class="next" href="https://lambertxiao.github.io/posts/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E5%85%A8o1%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/doc/">
    <span class="title">Next Page »</span>
    <br>
    <span>算法-全O(1)的数据结构</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Golang-epoll on twitter"
        href="https://twitter.com/intent/tweet/?text=Golang-epoll&amp;url=https%3a%2f%2flambertxiao.github.io%2fposts%2fgolang%2fgolang-epoll%2fdoc%2f&amp;hashtags=golang">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Golang-epoll on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flambertxiao.github.io%2fposts%2fgolang%2fgolang-epoll%2fdoc%2f&amp;title=Golang-epoll&amp;summary=Golang-epoll&amp;source=https%3a%2f%2flambertxiao.github.io%2fposts%2fgolang%2fgolang-epoll%2fdoc%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Golang-epoll on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2flambertxiao.github.io%2fposts%2fgolang%2fgolang-epoll%2fdoc%2f&title=Golang-epoll">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Golang-epoll on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flambertxiao.github.io%2fposts%2fgolang%2fgolang-epoll%2fdoc%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Golang-epoll on whatsapp"
        href="https://api.whatsapp.com/send?text=Golang-epoll%20-%20https%3a%2f%2flambertxiao.github.io%2fposts%2fgolang%2fgolang-epoll%2fdoc%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Golang-epoll on telegram"
        href="https://telegram.me/share/url?text=Golang-epoll&amp;url=https%3a%2f%2flambertxiao.github.io%2fposts%2fgolang%2fgolang-epoll%2fdoc%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer><div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "disqus_KY25sRiRtb" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://lambertxiao.github.io">Lambert&#39;s blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
